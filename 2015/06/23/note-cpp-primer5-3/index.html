<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="C++ Primer, 5th Edition的第三部分：类设计者的工具的笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer, 5th Edition 笔记3">
<meta property="og:url" content="http://conglang.github.io/2015/06/23/note-cpp-primer5-3/index.html">
<meta property="og:site_name" content="A Stellar Hiker">
<meta property="og:description" content="C++ Primer, 5th Edition的第三部分：类设计者的工具的笔记。">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_strvec_memory_strategy.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_overloadable_operators.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_when_to_use_overloaded_operators.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_choose_overload_type.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_equal_operator_notice.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_type_operator.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_name_searching_and_inheritance.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_stl_template_type_transformation.jpg">
<meta property="og:updated_time" content="2018-07-31T15:04:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ Primer, 5th Edition 笔记3">
<meta name="twitter:description" content="C++ Primer, 5th Edition的第三部分：类设计者的工具的笔记。">
<meta name="twitter:image" content="http://conglang.github.io/img/cpp_primer5_strvec_memory_strategy.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/astro.png">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/astro.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/astro.png">
          
        
    
    <!-- title -->
    <title>C++ Primer, 5th Edition 笔记3</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
  	<link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet">
</head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">博文</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2015/06/28/marcus-ai-recommendation/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2015/06/09/note-cpp-primer5-2/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/&text=C++ Primer, 5th Edition 笔记3"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/&title=C++ Primer, 5th Edition 笔记3"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/&is_video=false&description=C++ Primer, 5th Edition 笔记3"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++ Primer, 5th Edition 笔记3&body=Check out this article: http://conglang.github.io/2015/06/23/note-cpp-primer5-3/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/&title=C++ Primer, 5th Edition 笔记3"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/&title=C++ Primer, 5th Edition 笔记3"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/&title=C++ Primer, 5th Edition 笔记3"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/&title=C++ Primer, 5th Edition 笔记3"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/&name=C++ Primer, 5th Edition 笔记3&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#类设计者的工具"><span class="toc-number">1.</span> <span class="toc-text"> 类设计者的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#拷贝控制"><span class="toc-number">1.1.</span> <span class="toc-text"> 拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#拷贝-赋值与销毁"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 拷贝、赋值与销毁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#拷贝控制和资源管理"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 拷贝控制和资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#行为像值的类"><span class="toc-number">1.1.2.1.</span> <span class="toc-text"> 行为像值的类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#行为像指针的类"><span class="toc-number">1.1.2.2.</span> <span class="toc-text"> 行为像指针的类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#交换操作"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 交换操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态内存管理类"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 动态内存管理类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象移动"><span class="toc-number">1.1.5.</span> <span class="toc-text"> 对象移动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重载运算与类型转换"><span class="toc-number">1.2.</span> <span class="toc-text"> 重载运算与类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本概念"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输入和输出运算符"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 输入和输出运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#算术和关系运算符"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 算术和关系运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#赋值运算符"><span class="toc-number">1.2.4.</span> <span class="toc-text"> 赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#下标运算符"><span class="toc-number">1.2.5.</span> <span class="toc-text"> 下标运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#递增和递减运算符"><span class="toc-number">1.2.6.</span> <span class="toc-text"> 递增和递减运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#成员访问运算符"><span class="toc-number">1.2.7.</span> <span class="toc-text"> 成员访问运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数调用运算符"><span class="toc-number">1.2.8.</span> <span class="toc-text"> 函数调用运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重载-类型转换与运算符"><span class="toc-number">1.2.9.</span> <span class="toc-text"> 重载、类型转换与运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象程序设计"><span class="toc-number">1.3.</span> <span class="toc-text"> 面向对象程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#oop概述"><span class="toc-number">1.3.1.</span> <span class="toc-text"> OOP：概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义基类和派生类"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 定义基类和派生类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚函数"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#抽象基类"><span class="toc-number">1.3.4.</span> <span class="toc-text"> 抽象基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#访问控制与继承"><span class="toc-number">1.3.5.</span> <span class="toc-text"> 访问控制与继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继承中的类作用域"><span class="toc-number">1.3.6.</span> <span class="toc-text"> 继承中的类作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数与拷贝控制"><span class="toc-number">1.3.7.</span> <span class="toc-text"> 构造函数与拷贝控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#容器与继承"><span class="toc-number">1.3.8.</span> <span class="toc-text"> 容器与继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板与泛型编程"><span class="toc-number">1.4.</span> <span class="toc-text"> 模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义模板"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 定义模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模板实参推断"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 模板实参推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重载与模板"><span class="toc-number">1.4.3.</span> <span class="toc-text"> 重载与模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可变参数模板"><span class="toc-number">1.4.4.</span> <span class="toc-text"> 可变参数模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模板特例化"><span class="toc-number">1.4.5.</span> <span class="toc-text"> 模板特例化</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        C++ Primer, 5th Edition 笔记3
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">A Stellar Hiker</span>
      </span>
      
    <div class="postdate">
        <time datetime="2015-06-23T15:01:21.000Z" itemprop="datePublished">2015-06-23</time>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Book/">Book</a>, <a class="tag-link" href="/tags/C/">C++</a>, <a class="tag-link" href="/tags/STL/">STL</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="类设计者的工具"><a class="markdownIt-Anchor" href="#类设计者的工具"></a> 类设计者的工具</h2>
<h3 id="拷贝控制"><a class="markdownIt-Anchor" href="#拷贝控制"></a> 拷贝控制</h3>
<p>当定义一个类时，我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。</p>
<h4 id="拷贝-赋值与销毁"><a class="markdownIt-Anchor" href="#拷贝-赋值与销毁"></a> 拷贝、赋值与销毁</h4>
<p>拷贝构造函数的参数必须是引用类型。如<code>Sales_data(const Sales_data&amp;);</code>。<br>
重载赋值运算符，赋值运算符通常应该返回一个指向其左侧运算对象的引用。<code>Foo&amp; operator=(const Foo&amp;);</code>。<br>
析构函数没有参数，不能被重载。析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分进行的。<br>
需要析构函数的类也需要拷贝和赋值操作。需要拷贝操作的类也需要赋值操作，反之亦然。</p>
<p>可以通过将拷贝控制成员定义为<code>=default</code>来显式地要求编译器生成合成的版本。定义在类内的是内联函数，在类外的就不是了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Sales_data &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 拷贝控制成员；使用default</span></span><br><span class="line">	Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">	Sales_data(<span class="keyword">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br><span class="line">	Sales_data&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data &amp;);</span><br><span class="line">	~Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="comment">// 其他</span></span><br><span class="line">&#125;；</span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p>阻止拷贝，之前是通过将其拷贝构造函数和拷贝赋值运算符声明为private。现在不推荐用了，应该用C++11的方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">class</span> PrivateCopy &#123;</span><br><span class="line">	<span class="comment">// 无访问说明符；接下来的成员默认为private的；</span></span><br><span class="line">	<span class="comment">// 拷贝控制成员是private的，因此普通用户代码无法访问</span></span><br><span class="line">	PrivateCopy(<span class="keyword">const</span> PrivateCopy&amp;);</span><br><span class="line">	PrivateCopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> PrivateCopy&amp;);</span><br><span class="line">	<span class="comment">// 其他成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	PrivateCopy() = <span class="keyword">default</span>;	<span class="comment">// 使用合成的默认构造函数</span></span><br><span class="line">	~PrivateCopy();	<span class="comment">// 用户可以定义此类型的对象，但无法拷贝它们</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在C++11里，可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上<code>=delete</code>来指出我们希望将它定义为删除的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">struct</span> NoCopy &#123;</span><br><span class="line">	NoCopy() = <span class="keyword">default</span>;	<span class="comment">// 使用合成的默认构造函数</span></span><br><span class="line">	NoCopy(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;	<span class="comment">// 阻止拷贝</span></span><br><span class="line">	NoCopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;	<span class="comment">// 阻止赋值</span></span><br><span class="line">	~NoCopy() = <span class="keyword">default</span>;	<span class="comment">// 使用合成的析构函数</span></span><br><span class="line">	<span class="comment">// 其他</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>=delete</code>必须出现在函数第一次声明的时候，<code>=default</code>不是。可以对任何函数指定<code>=delete</code>，但只能对编译器可以合成的默认构造函数或拷贝控制成员使用<code>=default</code>。<br>
注意析构函数不能是删除的成员。<br>
如果一个类有const成员，则它不能使用合成的拷贝赋值运算符。毕竟，此运算符试图赋值所有成员，而将一个新值赋予一个const对象是不可能的。</p>
<h4 id="拷贝控制和资源管理"><a class="markdownIt-Anchor" href="#拷贝控制和资源管理"></a> 拷贝控制和资源管理</h4>
<p>拷贝语义有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。<br>
像一个值，意味它有自己的状态。拷贝出的副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。<br>
像一个指针，意味共享状态。拷贝出的副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。<br>
举例，在标准库中，标准库容器和string类的行为像一个值，shared_ptr类提供类似指针的行为，IO类型和unique_ptr不允许拷贝或赋值，行为既不像值也不像指针。</p>
<h5 id="行为像值的类"><a class="markdownIt-Anchor" href="#行为像值的类"></a> 行为像值的类</h5>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> HasPtr &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>()) : ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="comment">// 对ps指向的string，每个HasPtr对象都有自己的拷贝</span></span><br><span class="line">	HasPtr(<span class="keyword">const</span> HasPtr &amp;p) : ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*p.ps)), i(p.i) &#123;&#125;</span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;);</span><br><span class="line">	~HasPtr() &#123;<span class="keyword">delete</span> ps;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类值拷贝赋值运算符</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps);	<span class="comment">// 拷贝底层string</span></span><br><span class="line">	<span class="keyword">delete</span> ps;	<span class="comment">// 释放旧内存</span></span><br><span class="line">	ps = newp;	<span class="comment">// 从右侧运算对象拷贝数据到本对象</span></span><br><span class="line">	i = rhs.i;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;	<span class="comment">// 返回本对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写赋值运算符时要注意：</p>
<ul>
<li>如果将一个对象赋予它自身，赋值运算符必须能正确工作。</li>
<li>大多数赋值运算符组合了析构函数和拷贝构造函数的工作。销毁左侧运算对象资源之前拷贝右侧运算对象。</li>
</ul>
<h5 id="行为像指针的类"><a class="markdownIt-Anchor" href="#行为像指针的类"></a> 行为像指针的类</h5>
<p>需要定义拷贝构造函数和拷贝赋值运算符，最好使用shared_ptr来管理类中的资源。如果希望自己直接管理资源，使用引用计数。<br>
使用引用计数的示例(副本和原对象都指向相同的string)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> HasPtr &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数分配新的string和新的计数器，将计数器置为1</span></span><br><span class="line">	HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>()) : ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">	<span class="comment">// 拷贝构造函数拷贝所有三个数据成员，并递增计数器</span></span><br><span class="line">	HasPtr(<span class="keyword">const</span> HasPtr &amp;p) : ps(p.ps), i(p.i), use(p.use) &#123;++*use;&#125;</span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp;);</span><br><span class="line">	~HasPtr();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> *use;	<span class="comment">// 用来记录有多少个对象共享*ps的成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">HasPtr::~HasPtr()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(--*use == <span class="number">0</span>) &#123;	<span class="comment">// 如果引用计数变为0</span></span><br><span class="line">		<span class="keyword">delete</span> ps;		<span class="comment">// 释放string内存</span></span><br><span class="line">		<span class="keyword">delete</span> use;		<span class="comment">// 释放计数器内存</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载赋值运算符</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	++*rhs.use;	<span class="comment">// 递增右侧运算对象的引用计数</span></span><br><span class="line">	<span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123;	<span class="comment">// 然后递减本对象的引用计数</span></span><br><span class="line">		<span class="keyword">delete</span> ps;	<span class="comment">// 如果没有其他用户</span></span><br><span class="line">		<span class="keyword">delete</span> use;	<span class="comment">// 释放本对象分配的成员</span></span><br><span class="line">	&#125;</span><br><span class="line">	ps = rhs.ps;	<span class="comment">// 将数据从rhs拷贝到本对象</span></span><br><span class="line">	i = rhs.i;</span><br><span class="line">	use = rhs.use;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;	<span class="comment">// 返回本对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="交换操作"><a class="markdownIt-Anchor" href="#交换操作"></a> 交换操作</h4>
<p>对于那些与重排元素顺序的算法一起使用的类，定义swap是非常重要的。如果没有类自定义版本，算法会使用标准库定义的swap。理论上交换两个对象需要进行一次拷贝和两次赋值。如果是交换两个类值的HasPtr对象，会涉及到多次内存分配，没有必要，我们更希望swap交换指针，而不是分配string的新副本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> HasPtr &#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp;, HasPtr&amp;)</span></span>;</span><br><span class="line">	<span class="comment">// 其他成员定义，行为像值的类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">	swap(lhs.ps, rhs.ps);	<span class="comment">// 交换指针，而不是string数据</span></span><br><span class="line">	swap(lhs.i, rhs.i);	<span class="comment">// 交换int成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与拷贝控制成员不同，swap并不是必要的。但是，对于分配了资源的类，定义swap可能是一种很重要的优化手段。<br>
swap函数应该调用swap，而不是std::swap。防止该类有自定义swap却调用了std的。</p>
<p>可以在赋值运算符中使用swap。拷贝并交换，这种技术将左侧运算对象与右侧运算对象的一个副本进行交换。使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意rhs是按值传递的，意味着HasPtr的拷贝构造函数</span></span><br><span class="line"><span class="comment">// 将右侧运算对象中的string拷贝到rhs</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 交换左侧运算对象和局部变量rhs的内容</span></span><br><span class="line">	swap(*<span class="keyword">this</span>, rhs);	<span class="comment">// rhs现在指向本对象曾经使用的内存</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;	<span class="comment">// rhs被销毁，从而delete了rhs中的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态内存管理类"><a class="markdownIt-Anchor" href="#动态内存管理类"></a> 动态内存管理类</h4>
<p>示例，实现标准库vector类的一个简化版本。没使用模板，我们的类只用于string，命名为StrVec。</p>
<blockquote>
<p>StrVec类的设计</p>
</blockquote>
<p>vector类将其元素保存在连续内存中。为了获得可接受的性能，vector预先分配足够的内存来保存可能需要的更多元素。vector的每个添加元素的成员函数会检查是否有空间容纳更多的元素。如果有，成员函数会在下一个可用位置构造一个对象。如果没有可用空间，vector就会重新分配空间：它获得新的空间，将已有元素移动到新空间中，释放旧空间，并添加新元素。<br>
在StrVec中使用类似策略。使用allocator来获得原始内存，添加新元素的时候用construct创建对象，删除的时候用destroy。<br>
每个StrVec有三个指针成员指向其元素所使用的内存：</p>
<ul>
<li>elements，指向分配的内存中的首元素。</li>
<li>first_free，指向最后一个实际元素之后的位置。</li>
<li>cap，指向分配的内存末尾之后的位置。</li>
</ul>
<p><img src="/img/cpp_primer5_strvec_memory_strategy.jpg" alt="StrVec内存分配策略"><br>
还有一个名为alloc的静态成员，类型为allocator<string>。用于分配StrVec使用的内存。<br>
还有4个工具函数：</string></p>
<ul>
<li>alloc_n_copy会分配内存，并拷贝一个给定范围中的元素。</li>
<li>free会销毁构造的元素并释放内存。</li>
<li>chk_n_alloc保证StrVec至少有容纳一个新元素的空间。如果没有空间添加新元素，chk_n_alloc会调用reallocate来分配更多内存。</li>
<li>reallocate在内存用完时为StrVec分配新内存。</li>
</ul>
<blockquote>
<p>StrVec类定义</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> StrVec &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// allocator成员进行默认初始化</span></span><br><span class="line">	StrVec() : elements(<span class="literal">nullptr</span>), first_free(<span class="literal">nullptr</span>), cap(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	StrVec(<span class="keyword">const</span> StrVec&amp;);	<span class="comment">// 拷贝构造函数</span></span><br><span class="line">	StrVec &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> StrVec&amp;);	<span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">	~StrVec();	<span class="comment">// 析构函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;	<span class="comment">// 拷贝元素</span></span><br><span class="line">	<span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123;<span class="keyword">return</span> first_free - elements;&#125;</span><br><span class="line">	<span class="keyword">size_t</span> capacity() <span class="keyword">const</span> &#123;<span class="keyword">return</span> cap - elements;&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> *<span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> elements;&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> *<span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> first_free;&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; alloc;	<span class="comment">// 分配元素</span></span><br><span class="line">	<span class="comment">// 被添加元素的函数所使用</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">chk_n_alloc</span><span class="params">()</span> </span>&#123;<span class="keyword">if</span> (size() == capacity()) reallocate();&#125;</span><br><span class="line">	<span class="comment">// 工具函数，被拷贝构造函数、赋值运算符和析构函数所使用</span></span><br><span class="line">	<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*, <span class="built_in">std</span>::<span class="built_in">string</span>*&gt; alloc_n_copy(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>*, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>*);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;	<span class="comment">// 销毁元素并释放内存</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reallocate</span><span class="params">()</span></span>;	<span class="comment">// 获得更多内存并拷贝已有元素</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> *elements;	<span class="comment">// 指向数组首元素的指针</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> *first_free;	<span class="comment">// 指向数组第一个空闲元素的指针</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> *cap;	<span class="comment">// 指向数组尾后位置的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用construct</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> StrVec::push_back(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">	chk_n_alloc();	<span class="comment">// 确保有空间容纳新元素</span></span><br><span class="line">	<span class="comment">// 在first_free指向的元素中构造s的副本</span></span><br><span class="line">	alloc.construct(first_free++, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>alloc_n_copy成员</p>
</blockquote>
<p>拷贝或赋值StrVec，必须分配独立的内存，并从原StrVec对象拷贝元素至新对象。<br>
alloc_n_copy成员会分配足够的内存来保存给定范围的元素，并将这些元素拷贝到新分配的内存中。<br>
此函数返回一个指针的pair，两个指针分别指向新空间的开始位置和拷贝的尾后位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>*, <span class="built_in">string</span>*&gt;</span><br><span class="line">StrVec::alloc_n_copy(<span class="keyword">const</span> <span class="built_in">string</span> *b, <span class="keyword">const</span> <span class="built_in">string</span> *e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 分配空间保存给定范围中的元素</span></span><br><span class="line">	<span class="keyword">auto</span> data = alloc.allocate(e - b);	<span class="comment">// 尾后指针减去首元素指针，来计算需要多少空间。</span></span><br><span class="line">	<span class="comment">// 初始化并返回一个pair, 该pair由data和uninitialized_copy的返回值构成</span></span><br><span class="line">	<span class="keyword">return</span> &#123;data, uninitialized_copy(b, e, data)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>free成员</p>
</blockquote>
<p>首先destroy元素，然后释放StrVec自己分配的内存空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> strVec::<span class="built_in">free</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 不能传递给deallocate一个空指针，如果elements为0，函数什么也不做</span></span><br><span class="line">	<span class="keyword">if</span> (elements) &#123;</span><br><span class="line">		<span class="comment">// 逆序销毁旧元素</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> p = first_free; p != elements; <span class="comment">/*空*/</span>)</span><br><span class="line">			alloc.destroy(--p);</span><br><span class="line">		alloc.deallocate(elements, cap - elements);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>拷贝控制成员</p>
</blockquote>
<p>拷贝构造函数调用alloc_n_copy：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StrVec::StrVec(<span class="keyword">const</span> StrVec &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 调用alloc_n_copy分配空间以容纳与s中一样多的元素</span></span><br><span class="line">	<span class="keyword">auto</span> newdata = alloc_n_copy(s.begin(), s.end());</span><br><span class="line">	elements = newdata.first;</span><br><span class="line">	first_free = cap = newdata.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构函数调用free：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StrVec::~StrVec() &#123;<span class="built_in">free</span>();&#125;</span><br></pre></td></tr></table></figure>
<p>拷贝赋值运算符在释放已有元素之前调用alloc_n_copy，这样就可以正确处理自赋值了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(<span class="keyword">const</span> StrVec &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 调用alloc_n_copy分配内存，大小与rhs中元素占用空间一样多</span></span><br><span class="line">	<span class="keyword">auto</span> data = alloc_n_copy(rhs.begin(), rhs.end());</span><br><span class="line">	<span class="built_in">free</span>();</span><br><span class="line">	elements = data.first;</span><br><span class="line">	first_free = cap = data.second;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>reallocate成员</p>
</blockquote>
<p>在重新分配内存的过程中移动而不是拷贝元素<br>
reallocate函数应该：为一个新的、更大的string数组分配内存；在内存空间的前一部分构造对象，保存现有元素；销毁原内存空间中的元素，并释放这块内存。<br>
应尽量避免分配和释放string的额外开销。</p>
<p>使用移动构造函数和std::move。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> StrVec::reallocate()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 我们将分配当前大小两倍的内存空间</span></span><br><span class="line">	<span class="keyword">auto</span> newcapacity = size() ? <span class="number">2</span> * size() : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 分配新内存</span></span><br><span class="line">	<span class="keyword">auto</span> newdata = alloc.allocate(newcapacity);</span><br><span class="line">	<span class="comment">// 将数据从旧内存移动到新内存</span></span><br><span class="line">	<span class="keyword">auto</span> dest = newdata;	<span class="comment">// 指向新数组中下一个空闲位置</span></span><br><span class="line">	<span class="keyword">auto</span> elem = elements;	<span class="comment">// 指向旧数组中下一个元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != size(); ++i)</span><br><span class="line">		alloc.construct(dest++, <span class="built_in">std</span>::move(*elem++));</span><br><span class="line">	<span class="built_in">free</span>();	<span class="comment">// 一旦我们移动完元素就释放旧内存空间</span></span><br><span class="line">	<span class="comment">// 更新我们的数据结构，指向新元素</span></span><br><span class="line">	elements = newdata;</span><br><span class="line">	first_free = dest;</span><br><span class="line">	cap = elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对象移动"><a class="markdownIt-Anchor" href="#对象移动"></a> 对象移动</h4>
<p>从C++11开始。标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。</p>
<p>右值引用是必须绑定到右值的引用，通过&amp;&amp;获得，只能绑定到一个将要销毁的对象。因此可以自由地将一个右值引用的资源“移动”到另一个对象中。<br>
返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。可以将一个左值引用绑定到这类表达式的结果上。<br>
返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个const的左值引用或者一个右值引用绑定到这类表达式上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = i;	<span class="comment">// r引用i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i * <span class="number">42</span>;	<span class="comment">// 可以将一个const的引用绑定到一个右值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>;	<span class="comment">// 将rr2绑定到乘法结果上</span></span><br></pre></td></tr></table></figure>
<p>左值持久，右值短暂。右值引用只能绑定到临时对象，即该引用的对象将要被销毁，该对象没有其他用户。所以使用右值引用的代码可以自由地接管所引用的对象的资源。<br>
变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。</p>
<p>标准库move函数。可以显式地将一个左值转换为对应的右值引用类型。定义在头文件<code>&lt;utility&gt;</code>中。<br>
<code>int &amp;&amp;rr3 = std::move(rr1);</code>注意使用<code>std::move</code>而不是move，避免潜在的名字冲突。</p>
<blockquote>
<p>移动构造函数和移动赋值运算符</p>
</blockquote>
<p>接着前文的例子，让StrVec类支持移动和拷贝。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在声明时</span></span><br><span class="line"><span class="keyword">class</span> StrVec &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StrVec(StrVec&amp;&amp;) <span class="keyword">noexcept</span>;	<span class="comment">// 移动构造函数</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在定义时，移动构造函数</span></span><br><span class="line">StrVec::StrVec(StrVec &amp;&amp;s) <span class="keyword">noexcept</span>	<span class="comment">// 移动操作不应抛出任何异常</span></span><br><span class="line"><span class="comment">// 成员初始化器接管s中的资源</span></span><br><span class="line">: elements(s.elements), first_free(s.first_free), cap(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 令s进入这样的状态——对其运行析构函数是安全的</span></span><br><span class="line">	<span class="comment">// 不然销毁移后源会释放掉我们刚刚移动的内存</span></span><br><span class="line">	s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移动赋值运算符</span></span><br><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 直接检测自赋值</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> != rhs) &#125;</span><br><span class="line">		<span class="built_in">free</span>();	<span class="comment">// 释放已有元素</span></span><br><span class="line">		elements = rhs.elements;	<span class="comment">// 从rhs接管资源</span></span><br><span class="line">		first_free = rhs.first_free;</span><br><span class="line">		cap = rhs.cap;</span><br><span class="line">		<span class="comment">// 将rhs置于可析构状态</span></span><br><span class="line">		rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。因为为了避免潜在的一半在原地一半被移走的问题，除非容器知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数。<br>
只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。<br>
定义了一个移动构造函数或移动赋值运算符的类也必须定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。<br>
移动右值，拷贝左值，但如果没有移动构造函数，右值也被拷贝。</p>
<p><strong>对于行为像指针的类HasPtr定义拷贝并交换赋值运算符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> HasPtr &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 添加的移动构造函数</span></span><br><span class="line">	HasPtr(HasPtr &amp;&amp;p) <span class="keyword">noexcept</span> : ps(p.ps), i(p.i) &#123;p.ps = <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="comment">// 赋值运算符既是移动赋值运算符，也是拷贝赋值运算符</span></span><br><span class="line">	<span class="comment">// 依赖于实参的类型，左值被拷贝，右值被移动</span></span><br><span class="line">	HasPtr&amp; <span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">		&#123;swap(*<span class="keyword">this</span>, rhs); <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用移动迭代器重写reallocate</p>
</blockquote>
<p>C++11中提供了一种移动迭代器。移动迭代器的解引用运算符生成一个右值引用。使用<code>make_move_iterator</code>将一个普通迭代器转换为一个移动迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> StrVec::reallocate()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 分配大小两倍于当前规模的内存空间</span></span><br><span class="line">	<span class="keyword">auto</span> newcapaciy = size() ? <span class="number">2</span> * size() : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> first = alloc.allocate(newcapacity);</span><br><span class="line">	<span class="comment">// 移动元素</span></span><br><span class="line">	<span class="keyword">auto</span> last = uninitialized_copy(make_move_iterator(begin()),</span><br><span class="line">				make_move_iterator(end()), first);</span><br><span class="line">	<span class="built_in">free</span>();	<span class="comment">// 释放旧空间</span></span><br><span class="line">	elements = first;	<span class="comment">// 更新指针</span></span><br><span class="line">	first_free = last;</span><br><span class="line">	cap = elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**建议不要随意使用移动操作。**由于一个移动源对象具有不确定的状态，对其调用std::move是危险的。当我们调用move时，必须绝对确认移后源对象没有其他用户。小心的使用move可以大幅提升性能，随意使用就等着哭吧。</p>
<blockquote>
<p>重载版本的push_back</p>
</blockquote>
<p>如果一个成员函数同时提供拷贝和移动版本，一般成员函数也会有重载，一个接受指向const的左值引用，一个接受指向非const的右值引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> StrVec &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;	<span class="comment">// 拷贝元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp;)</span></span>;	<span class="comment">// 移动元素</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 移动元素的push_back</span></span><br><span class="line"><span class="keyword">void</span> StrVec::push_back(<span class="built_in">string</span> &amp;&amp;s)</span><br><span class="line">&#123;</span><br><span class="line">	chk_n_alloc();	<span class="comment">// 如果需要的话为StrVec重新分配内存</span></span><br><span class="line">	alloc.construct(first_free++, <span class="built_in">std</span>::move(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用限定符暂略。</p>
<h3 id="重载运算与类型转换"><a class="markdownIt-Anchor" href="#重载运算与类型转换"></a> 重载运算与类型转换</h3>
<h4 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h4>
<p>当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的(显式)参数数量比运算对象的数量少一个。<br>
对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数。这也意味着当运算符用于内置类型的运算对象时，我们无法改变运算符的含义。<br>
并不是所有的运算符都可以重载。<br>
<img src="/img/cpp_primer5_overloadable_operators.jpg" alt="运算符"><br>
可以直接调用一个重载的运算符函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">operator+(data1, data2);	// 对非成员运算符函数的调用</span><br><span class="line">data1.operator+=(data2);	// 对成员运算符函数的调用</span><br></pre></td></tr></table></figure>
<p>通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。</p>
<p><img src="/img/cpp_primer5_when_to_use_overloaded_operators.jpg" alt="Image Loading"></p>
<p>将运算符定义为成员函数还是普通的非成员函数，做决定的准则：<br>
<img src="/img/cpp_primer5_choose_overload_type.jpg" alt="Image Loading"></p>
<h4 id="输入和输出运算符"><a class="markdownIt-Anchor" href="#输入和输出运算符"></a> 输入和输出运算符</h4>
<p>输入输出运算符必须是非成员函数。否则，它们的左侧运算对象将是我们的类的一个对象。所以IO运算符一般被声明为友元。<br>
<strong>重载输出运算符<code>&lt;&lt;</code></strong><br>
通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">	os &lt;&lt; item.isbn() &lt;&lt; <span class="string">" "</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">" "</span></span><br><span class="line">		&lt;&lt; item.revenue &lt;&lt; <span class="string">" "</span> &lt;&lt; item.avg_price();</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重载输入运算符<code>&gt;&gt;</code></strong><br>
输入运算符必须处理输入可能失败的情况，而输出运算符不需要。<br>
当读取操作发生错误时，输入运算符应该负责从错误中恢复。<br>
可能发生的错误：</p>
<ul>
<li>当流含有错误类型的数据时读取操作可能失败。</li>
<li>当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">double</span> price;	<span class="comment">// 不需要初始化，因为我们先读入数据到price，之后才使用它</span></span><br><span class="line">	is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">	<span class="keyword">if</span> (is)	<span class="comment">// 检查输入是否成功</span></span><br><span class="line">		item.revenue = item.units_sold * price;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		item = Sales_data();	<span class="comment">// 输入失败，对象被赋予默认的状态</span></span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算术和关系运算符"><a class="markdownIt-Anchor" href="#算术和关系运算符"></a> 算术和关系运算符</h4>
<p>一般定义为非成员函数，以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。</p>
<p>如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设两个对象指向同一本书</span></span><br><span class="line">Sales_data</span><br><span class="line"><span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Sales_data sum = lhs;	<span class="comment">// 把lhs的数据成员拷贝给sum</span></span><br><span class="line">	sum += rhs;	<span class="comment">// 把rhs加到sum中</span></span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果某个类在逻辑上有相等性的含义，应该定义<code>operator==</code>。<br>
<img src="/img/cpp_primer5_equal_operator_notice.jpg" alt="Image Loading"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> lhs.isbn() == rhs.isbn() &amp;&amp;</span><br><span class="line">		lhs.units_sold == rhs.units_sold &amp;&amp;</span><br><span class="line">		lhs.revenue == rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包含==，则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符。</p>
<h4 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符"></a> 赋值运算符</h4>
<p>可以重载赋值运算符，不论形参的类型是什么，赋值运算符都必须定义为成员函数。复合赋值运算符也通常如此。它们都应该返回左侧运算对象的引用。</p>
<blockquote>
<p>StrVec中的赋值运算符重载</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> StrVec &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	StrVec &amp;<span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;);</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// alloc_n_copy分配内存空间并从给定范围内拷贝元素</span></span><br><span class="line">	<span class="keyword">auto</span> data = alloc_n_copy(il.begin(), il.end());</span><br><span class="line">	<span class="built_in">free</span>();	<span class="comment">// 销毁对象中的元素并释放内存空间</span></span><br><span class="line">	elements = data.first;	<span class="comment">// 更新数据成员使其指向新空间</span></span><br><span class="line">	first_free = cap = data.second;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假定两个对象表示的是同一本书</span></span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	units_sold += rhs.units_sold;</span><br><span class="line">	revenue += rhs.revenue;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="下标运算符"><a class="markdownIt-Anchor" href="#下标运算符"></a> 下标运算符</h4>
<p>表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。<br>
下标运算符必须是成员函数。<br>
如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。</p>
<blockquote>
<p>StrVec的下标运算符</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> StrVec &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) &#123;<span class="keyword">return</span> elements[n];&#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span></span><br><span class="line">	&#123;<span class="keyword">return</span> elements[n];&#125;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> *elements;	<span class="comment">// 指向数组首元素的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递增和递减运算符"><a class="markdownIt-Anchor" href="#递增和递减运算符"></a> 递增和递减运算符</h4>
<p>建议把递增和递减运算符设定为成员函数。<br>
定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员。<br>
为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。<br>
为了与内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。<br>
为了区分前置和后置运算符，后置版本接受一个额外的（不被使用）int类型的形参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> StrBlobPtr &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 前置，递增和递减运算符</span></span><br><span class="line">	StrBlobPtr&amp; <span class="keyword">operator</span>++();</span><br><span class="line">	StrBlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line">	<span class="comment">// 后置，递增和递减运算符</span></span><br><span class="line">	StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>);</span><br><span class="line">	StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 前置版本：返回递增/递减对象的引用</span></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 如果curr已经指向了容器的尾后位置，则无法递增它</span></span><br><span class="line">	check(curr, <span class="string">"increment past end of StrBlobPtr"</span>);</span><br><span class="line">	++curr;	<span class="comment">// 将curr在当前状态下向前移动一个元素</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 如果curr是0，则继续递减它将产生一个无效下标</span></span><br><span class="line">	--curr;	<span class="comment">// 将curr在当前状态下向后移动一个元素</span></span><br><span class="line">	check(curr, <span class="string">"decrement past begin of StrBlobPtr"</span>);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后置版本：递增/递减对象的值但是返回原值</span></span><br><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 此处无需检查有效性，调用前置递增运算时才需要检查</span></span><br><span class="line">	StrBlobPtr ret = *<span class="keyword">this</span>;	<span class="comment">// 记录当前的值</span></span><br><span class="line">	++*<span class="keyword">this</span>;	<span class="comment">// 向前移动一个元素，前置++需要检查递增的有效性</span></span><br><span class="line">	<span class="keyword">return</span> ret;	<span class="comment">// 返回之前记录的状态</span></span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">	--*<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="成员访问运算符"><a class="markdownIt-Anchor" href="#成员访问运算符"></a> 成员访问运算符</h4>
<p>在迭代器类及智能指针类中常常用到解引用运算符<code>*</code>和箭头计算符<code>-&gt;</code>。<br>
箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。<br>
重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> StrBlobPtr &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> p = check(curr, <span class="string">"dereference past end"</span>);</span><br><span class="line">		<span class="keyword">return</span> (*p)[curr];	<span class="comment">// (*p)是对象所指的vector</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span>* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将实际工作委托给解引用运算符</span></span><br><span class="line">		<span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数调用运算符"><a class="markdownIt-Anchor" href="#函数调用运算符"></a> 函数调用运算符</h4>
<p>函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。<br>
函数对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> absInt &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val &lt; <span class="number">0</span> ? -val : val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lambda是函数对象。标准库定义了很多函数对象。</p>
<p>C++语言中有几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。<br>
不同类型的可调用对象可以共享同一种调用形式。如<code>int(int, int)</code>。<br>
可以使用标准库的<strong>function</strong>类型将它们统一为一种格式。定义在<code>functional</code>头文件中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> i+j;&#125;</span><br><span class="line"><span class="comment">// lambda，其产生一个未命名的函数对象类</span></span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;<span class="keyword">return</span> i % j;&#125;;</span><br><span class="line"><span class="comment">// 函数对象类</span></span><br><span class="line"><span class="keyword">struct</span> divide &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> denominator, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> denominator / divisor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 列举了可调用对象与二元运算符对应关系的表格</span></span><br><span class="line"><span class="comment">// 所有可调用对象都必须接受两个int、返回一个int</span></span><br><span class="line"><span class="comment">// 其中的元素可以是函数指针、函数对象或者lambda</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt;&gt; binops = &#123;</span><br><span class="line">	&#123;<span class="string">"+"</span>, add&#125;,				<span class="comment">// 函数指针</span></span><br><span class="line">	&#123;<span class="string">"-"</span>, <span class="built_in">std</span>::minus&lt;<span class="keyword">int</span>&gt;()&#125;,		<span class="comment">// 标准库函数对象</span></span><br><span class="line">	&#123;<span class="string">"/"</span>, divide()&#125;,			<span class="comment">// 用户定义的函数对象</span></span><br><span class="line">	&#123;<span class="string">"*"</span>, [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;<span class="keyword">return</span> i*j;&#125;&#125;,	<span class="comment">// 未命名的lambda</span></span><br><span class="line">	&#123;<span class="string">"%"</span>, mod&#125;				<span class="comment">// 命名了的lambda对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="重载-类型转换与运算符"><a class="markdownIt-Anchor" href="#重载-类型转换与运算符"></a> 重载、类型转换与运算符</h4>
<p>类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。<br>
<code>operator type() const;</code><br>
一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是const。<br>
避免过度使用类型转换函数，为防止意外的隐式转换，可以定义为显式的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SmallInt &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	SmallInt(<span class="keyword">int</span> i = <span class="number">0</span>) : val(i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;<span class="number">255</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Bad SmallInt Value"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 编译器不会自动执行这一类型转换</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>:：<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si = <span class="number">3</span>;	<span class="comment">// SmallInt的构造函数不是显式的</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si)+<span class="number">3</span>;	<span class="comment">// 显式地请求类型转换</span></span><br></pre></td></tr></table></figure>
<p>为了避免有二义性的类型转换。通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。<br>
<img src="/img/cpp_primer5_type_operator.jpg" alt="Image Loading"><br>
如果在调用函数重载函数时我们需要使用构造函数或者强制类型转换来改变实参的类型，这通常意味着程序的设计存在不足。</p>
<p>重载的运算符也是重载的函数。表达式中运算符的候选函数集既应该包括成员函数，也应该包括非成员函数。<br>
如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则会遇到重载运算符与内置运算符的二义性问题。</p>
<h3 id="面向对象程序设计"><a class="markdownIt-Anchor" href="#面向对象程序设计"></a> 面向对象程序设计</h3>
<h4 id="oop概述"><a class="markdownIt-Anchor" href="#oop概述"></a> OOP：概述</h4>
<p>OOP的核心是数据抽象、继承和动态绑定。通过使用数据抽象，可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</p>
<p>小结：<br>
继承使得我们可以编写一些新的类，这些新类既能共享其基类的行为，又能根据需要覆盖或添加行为。动态绑定使得我们可以忽略类型之间的差异，其机理是在运行时根据对象的动态类型来选择运行函数的哪个版本。继承和动态绑定的结合使得我们能够编写具有特定类型行为但又独立于类型的程序。<br>
在C++语言中，动态绑定只作用于虚函数，并且需要通过指针或引用调用。<br>
在派生类对象中包含有与它的每个基类对应的子对象。因为所有派生类对象都含有基类部分，所以我们能将派生类的引用或指针转换为一个可访问的基类引用或指针。<br>
当执行派生类的构造、拷贝、移动和赋值操作时，首先构造、拷贝、移动和赋值其中的基类部分，然后才轮到派生类部分。析构函数的执行顺序则正好相反，首先销毁派生类，接下来执行基类子对象的析构函数。基类通常都应该定义一个虚析构函数，即使基类根本不需要析构函数也最好这么做。将基类的析构函数定义成虚函数的原因是为了确保当我们删除一个基类指针，而该指针实际指向一个派生类对象时，程序也能正确运行。<br>
派生类为它的每个基类提供一个保护级别。public基类的成员也是派生类接口的一部分；private基类的成员是不可访问的；protected基类的成员对于派生类的派生类是可访问的，但是对于派生类的用户不可访问。</p>
<h4 id="定义基类和派生类"><a class="markdownIt-Anchor" href="#定义基类和派生类"></a> 定义基类和派生类</h4>
<p>基类应该定义虚析构函数。<br>
在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。<br>
每个类控制它自己的成员初始化过程。首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。</p>
<p>在C++11中如果不希望其他类继承某个类，可以将该类设置为<code>final</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> NoDerived final &#123;&#125;;	<span class="comment">// NoDerived不能作为基类</span></span><br><span class="line"><span class="keyword">class</span> Base &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> Last final : Base &#123;&#125;;	<span class="comment">// Last不能作为基类</span></span><br></pre></td></tr></table></figure>
<p>从派生类到基类的类型转换只对指针或引用类型有效。</p>
<h4 id="虚函数"><a class="markdownIt-Anchor" href="#虚函数"></a> 虚函数</h4>
<p>基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。<br>
派生类中虚函数的返回类型也必须与基类函数匹配。唯一的例外是，类的虚函数返回类型是类本身的指针或引用时，不过要求从派生类到基类的类型转换是可访问的。</p>
<p>为了防止派生类覆盖基类虚函数时不匹配，C++11中建议显式写上<code>override</code>，有问题会报错。<code>void f(int) const override;</code>。<br>
将某个函数指定为<code>final</code>则之后该函数不能再被覆盖。<code>void f(int) const final;</code>。</p>
<p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</p>
<h4 id="抽象基类"><a class="markdownIt-Anchor" href="#抽象基类"></a> 抽象基类</h4>
<p>含有纯虚函数的类是抽象基类。不能创建抽象基类的对象。</p>
<h4 id="访问控制与继承"><a class="markdownIt-Anchor" href="#访问控制与继承"></a> 访问控制与继承</h4>
<p>每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否可访问。</p>
<p>类的protected说明符：</p>
<ul>
<li>和私有成员类似，受保护的成员对于类的用户是不可访问的。</li>
<li>和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。</li>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</li>
</ul>
<p>公有、私有和受保护继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;	<span class="comment">// public成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> prot_mem;	<span class="comment">// protected成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> priv_mem;	<span class="comment">// private成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> Pub_Derv : <span class="keyword">public</span> Base &#123;</span><br><span class="line">	<span class="comment">// 正确：派生类能访问protected成员</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;</span><br><span class="line">	<span class="comment">// 错误：private成员对于派生类来说是不可访问的</span></span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">g</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> priv_mem;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> Priv_Derv : <span class="keyword">private</span> Base &#123;</span><br><span class="line">	<span class="comment">// private不影响派生类的访问权限</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生访问说明符的目的是控制派生类用户(包括派生类的派生类在内)对于基类成员的访问权限：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pub_Derv d1;	<span class="comment">// 继承自Base的成员是public的</span></span><br><span class="line">Priv_Derv d2;	<span class="comment">// 继承自Base的成员是Private的</span></span><br><span class="line">d1.pub_mem();	<span class="comment">// 正确：pub_mem在派生类中是public的</span></span><br><span class="line">d2.pub_mem();	<span class="comment">// 错误：pub_mem在派生类中是private的</span></span><br></pre></td></tr></table></figure>
<p>派生访问说明符还可以控制继承自派生类的新类的访问权限：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Derived_from_Public : <span class="keyword">public</span> Pub_Derv &#123;</span><br><span class="line">	<span class="comment">// 正确：Base::prot_mem在Pub_Derv中仍然是protected的</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> Derived_from_Private : <span class="keyword">public</span> Priv_Derv &#123;</span><br><span class="line">	<span class="comment">// 错误：Base::prot_mem在Priv_Derv中是private的</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>基类应该将接口成员声明为公有的；将属于实现的部分分为两组：一组可供派生类访问，声明为受保护的；一组只能由基类及基类的友元访问，声明为私有的。</p>
<p>可以用<code>using</code>声明改变个别成员的可访问性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Derived : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 保持对象尺寸相关的成员的访问级别</span></span><br><span class="line">	<span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类只能为那些它可以访问的名字提供using声明。</p>
<h4 id="继承中的类作用域"><a class="markdownIt-Anchor" href="#继承中的类作用域"></a> 继承中的类作用域</h4>
<p>当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。所以派生类才能像使用自己的成员一样使用基类的成员。<br>
派生类的成员将隐藏同名的基类成员。可以通过作用域运算符来使用隐藏的成员。除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。<br>
<img src="/img/cpp_primer5_name_searching_and_inheritance.jpg" alt="Image Loading"><br>
名字查找先于类型查找。如果内层作用域的成员与外层作用域的某个成员同名，即使形参列表不一致，外层作用域该成员也会被隐藏掉。</p>
<h4 id="构造函数与拷贝控制"><a class="markdownIt-Anchor" href="#构造函数与拷贝控制"></a> 构造函数与拷贝控制</h4>
<p>基类应该定义一个虚析构函数。否则delete一个指向派生类对象的基类指针将产生未定义的行为。<br>
(略过部分内容)</p>
<h4 id="容器与继承"><a class="markdownIt-Anchor" href="#容器与继承"></a> 容器与继承</h4>
<p>当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容。一般在容器中放置(智能)指针而非对象。</p>
<h3 id="模板与泛型编程"><a class="markdownIt-Anchor" href="#模板与泛型编程"></a> 模板与泛型编程</h3>
<h4 id="定义模板"><a class="markdownIt-Anchor" href="#定义模板"></a> 定义模板</h4>
<p><strong>函数模板</strong><br>
例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">foo</span><span class="params">(T* p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	T tmp = *p;	<span class="comment">// tmp的类型将是指针p指向的类型</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">TreeNode n = foo(node);</span><br><span class="line"><span class="comment">// 编译器实例化出的是：</span></span><br><span class="line"><span class="function">TreeNode <span class="title">foo</span><span class="params">(TreeNode* p)</span></span>;</span><br></pre></td></tr></table></figure>
<p>也可以有非类型模板参数，一个非类型参数表示一个值而非一个类型。当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替，这些值必须是常量表达式。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;unsigned N, unsigned M&gt;</span><br><span class="line">int compare(const char (&amp;p1)[N], const char (&amp;p2)[M])</span><br><span class="line">&#123;</span><br><span class="line">	return strcmp(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">// 调用</span><br><span class="line">compare("hi", "mom");</span><br><span class="line">// 编译器实例化出的是：</span><br><span class="line">int compare(const char (&amp;p1)[3], const char (&amp;p2)[4]);</span><br></pre></td></tr></table></figure>
<p>模板程序应该尽量减少对实参类型的要求。<br>
当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。<br>
函数模板和类模板成员函数的定义通常放在头文件中。<br>
保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。</p>
<p><strong>类模板</strong><br>
与函数模板的不同之处是，编译器不能为类模板推断模板参数类型，必须提供模板实参。<br>
例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Blob &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;::size_type size_type;</span><br><span class="line">	<span class="comment">// 构造函数</span></span><br><span class="line">	Blob();</span><br><span class="line">	Blob(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; il);</span><br><span class="line">	<span class="comment">// Blob中的元素数目</span></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> data-&gt;size();&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> data-&gt;empty();&#125;</span><br><span class="line">	<span class="comment">// 添加和删除元素</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;data-&gt;push_back(t);&#125;</span><br><span class="line">	<span class="comment">// 移动版本</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;data-&gt;push_back(<span class="built_in">std</span>::move(t));&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 元素访问</span></span><br><span class="line">	<span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>[](size_type i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; data;</span><br><span class="line">	<span class="comment">// 若data[i]无效，则抛出msg</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用时</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;	<span class="comment">// 有5个元素的Blob&lt;int&gt;。</span></span><br></pre></td></tr></table></figure>
<p>一个类模板的每个实例都形成一个独立的类。类型Blob<string>与任何其他Blob类型都没有关联，也不会对任何其他Blob类型的成员有特殊访问权限。<br>
在模板作用域中引用模板类型，例如：<br>
<code>std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data;</code><br>
可以在类模板外部定义成员函数。而定义在类模板内的成员函数被隐式声明为内联函数。</string></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ret-type Blob&lt;T&gt;::member-name (param-<span class="built_in">list</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>以构造函数为例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob()</span><br><span class="line">: data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;())</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。<br>
在一个类模板的作用域内，可以直接使用模板名而不必指定模板实参。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BlobPtr ret = *<span class="keyword">this</span>;	<span class="comment">// 不用写为BlobPtr&lt;T&gt; ret = *this;</span></span><br><span class="line">	++*<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。<br>
例如，一对一友好关系，对应实例及其友元间的友好关系。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置声明，在Blob中声明友元所需要的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> BlobPtr;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> Blob;	<span class="comment">// 运算符==中的参数所需要的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Blob &#123;</span><br><span class="line">	<span class="comment">// 每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> BlobPtr&lt;T&gt;;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==&lt;T&gt; (<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，设置通用或特定的模板友好关系。注意为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置声明，在将模板的一个特定实例声明为友元时要用到</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Pal;</span><br><span class="line"><span class="keyword">class</span> C &#123;	<span class="comment">// C是一个普通的非模板类</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> Pal&lt;C&gt;;	<span class="comment">// 用类C实例化的Pal是C的一个友元</span></span><br><span class="line">	<span class="comment">// Pal2的所有实例都是C的友元；这种情况无需前置声明。</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="keyword">class</span> Pal2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> C2 &#123;	<span class="comment">// C2本身是一个类模板</span></span><br><span class="line">	<span class="comment">// C2的每个实例将相同实例化的Pal声明为友元</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> Pal&lt;T&gt;;	<span class="comment">// Pal的模板声明必须在作用域之内</span></span><br><span class="line">	<span class="comment">// Pal2的所有实例都是C2的每个实例的友元，不需要前置声明</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="keyword">class</span> Pal2;</span><br><span class="line">	<span class="comment">// Pal3是一个非模板类，它是C2所有实例的友元</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> Pal3;	<span class="comment">// 不需要Pal3的前置声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>模板自己的类型参数也可以成为友元。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="keyword">class</span> Bar &#123;</span><br><span class="line"><span class="keyword">friend</span> Type;	<span class="comment">// 将访问权限授予用来实例化Bar的类型。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以为类模板定义一个类型别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;<span class="built_in">string</span>&gt; authors;	<span class="comment">// authors是一个pair&lt;string, string&gt;</span></span><br></pre></td></tr></table></figure>
<p>定义一个模板类型别名时，可以固定一个或多个模板参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> partNo = pair&lt;T, <span class="keyword">unsigned</span>&gt;;</span><br><span class="line">partNo&lt;<span class="built_in">string</span>&gt; books;	<span class="comment">// books是一个pair&lt;string, unsigned&gt;</span></span><br></pre></td></tr></table></figure>
<p>类模板可以有static成员，类模板的每个实例都有一个独有的static对象，一个static成员函数也只有在使用时才会实例化。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Foo &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> count() &#123;<span class="keyword">return</span> ctr;&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> ctr;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Foo&lt;T&gt;:ctr = <span class="number">0</span>;	<span class="comment">// 定义并初始化ctr</span></span><br></pre></td></tr></table></figure>
<p><strong>模板参数</strong><br>
模板参数遵循普通的作用域规则。在模板内不能重用模板参数名。<br>
一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。<br>
默认情况下，C++语言假定通过使用作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型，用typename。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> T::<span class="function">value_type <span class="title">top</span><span class="params">(<span class="keyword">const</span> T&amp; c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!c.empty())</span><br><span class="line">		<span class="keyword">return</span> c.back();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">typename</span> T::value_type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以提供默认模板实参，从C++11起，可以为函数和类模板提供默认实参，之前只能为类模板提供默认实参。<br>
函数模板提供默认实参，例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// compare有一个默认模板实参less&lt;T&gt;和一个默认函数实参F()</span><br><span class="line">template &lt;typename T, typename F = less&lt;T&gt;&gt;</span><br><span class="line">int compare(const T&amp; v1, const T&amp; v2, F f = F())</span><br><span class="line">&#123;</span><br><span class="line">	if (f(v1, v2)) return -1;</span><br><span class="line">	if (f(v2, v1)) return 1;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">// 调用</span><br><span class="line">bool i = compare(0, 42);	// 使用less;i为-1</span><br><span class="line">// 结果依赖于item1和item2中的isbn</span><br><span class="line">Sales_data item1(cin), item2(cin);</span><br><span class="line">bool j = compare(item1, item2, compareIsbn);</span><br></pre></td></tr></table></figure>
<p>类模板提供默认实参，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keyword">int</span>&gt; <span class="keyword">class</span> Numbers &#123;	<span class="comment">// T默认为int</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Numbers(T v = <span class="number">0</span>):val(v) &#123;&#125;</span><br><span class="line">	<span class="comment">// 对数值的各种操作</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision;	<span class="comment">// 空&lt;&gt;表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure>
<p><strong>成员模板</strong><br>
一个类(无论是普通类还是类模板)可以包含本身是模板的成员函数。这种成员就是成员模板。成员模板不能是虚函数。<br>
普通(非模板)类的成员模板，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数对象类，对给定指针执行delete</span></span><br><span class="line"><span class="keyword">class</span> DebugDelete &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	DebugDelete(<span class="built_in">std</span>::ostream&amp; s = <span class="built_in">std</span>::<span class="built_in">cerr</span>) : os(s) &#123;&#125;</span><br><span class="line">	<span class="comment">// 与任何函数模板相同，T的类型由编译器推断</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(T* p)</span> <span class="keyword">const</span></span><br><span class="line">	</span>&#123;os &lt;&lt; <span class="string">"deleting unique_ptr"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="keyword">delete</span> p;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::ostream&amp; os;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">double</span>* p = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">DebugDelete d;	<span class="comment">// 可像delete表达式一样使用的对象</span></span><br><span class="line">d(p);	<span class="comment">// 调用DebugDelete::operator()(double*)，释放p</span></span><br><span class="line"><span class="keyword">int</span>* ip = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">DebugDelete()(ip);	<span class="comment">// 在一个临时DebugDelete对象上调用operator()(int*)</span></span><br><span class="line"><span class="comment">// 可以将DebugDelete用作unique_ptr的删除器</span></span><br><span class="line"><span class="comment">// 销毁p指向的对象，实例化DebugDelete::operator()&lt;int&gt;(int*)</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>, DebugDelete&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>, DebugDelete());</span><br><span class="line"><span class="comment">// 销毁sp指向的对象，实例化DebugDelete::operator()&lt;string&gt;(string*)</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>, DebugDelete&gt; sp(<span class="keyword">new</span> <span class="built_in">string</span>, DebugDelete());</span><br></pre></td></tr></table></figure>
<p>类模板的成员函数，在此情况下，类和成员各自有自己的、独立的模板参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Blob &#123;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; Blob(It b, It e);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;	<span class="comment">// 类的类型参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;	<span class="comment">// 构造函数的类型参数</span></span><br><span class="line">Blob&lt;T&gt;::Blob(It b, It e) : data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;(b, e)) &#123;&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; a1(begin(ia), end(ia));</span><br></pre></td></tr></table></figure>
<p><strong>控制实例化</strong><br>
当模板被使用时才会进行实例化，这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。<br>
C++11中，通过显式实例化来避免这种开销，以这种形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;	<span class="comment">// 实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;	<span class="comment">// 实例化定义</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> Blob&lt;<span class="built_in">string</span>&gt;;	<span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;	<span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>
<p>对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何使用此实例化版本的代码之前。实例化定义会实例化所有成员。</p>
<p><strong>效率与灵活性</strong><br>
通过在编译时绑定删除器，unique_ptr避免了间接调用删除器的运行时开销。通过在运行时绑定删除器，shared_ptr使用户重载删除器更为方便。</p>
<h4 id="模板实参推断"><a class="markdownIt-Anchor" href="#模板实参推断"></a> 模板实参推断</h4>
<p>从函数实参来确定模板实参的过程称为模板实参推断。<br>
<strong>类型转换与模板类型参数</strong><br>
将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换。<br>
例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fobj</span><span class="params">(T, T)</span></span>;	<span class="comment">// 实参被拷贝</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fref</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;	<span class="comment">// 引用</span></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"a"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"b"</span>)</span></span>;</span><br><span class="line">fobj(s1, s2);	<span class="comment">// 调用fobj(string, string); const被忽略</span></span><br><span class="line">fref(s1, s2);	<span class="comment">// 调用fref(const string&amp;, const string&amp;)，将s1转换为const是允许的</span></span><br><span class="line"><span class="comment">// int数组</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], b[<span class="number">42</span>];</span><br><span class="line">fobj(a, b);	<span class="comment">// 调用f(int*, int*); 两个数组都被转换为指针</span></span><br><span class="line">fref(a, b);	<span class="comment">// 错误：数组类型不匹配。如果形参是一个引用，数组不会转换为指针。两个数组大小不同，因此是不同类型。</span></span><br></pre></td></tr></table></figure>
<p>如果函数参数类型不是模板参数，则对实参进行正常的类型转换。</p>
<p><strong>函数模板显式实参</strong><br>
显示模板实参按从左到右的顺序与对应的模板参数匹配，所以要显式写的定义在最左边。<br>
例如，允许用户指定函数的返回类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器无法推断T1，它未出现在函数参数列表中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// T1是显示指定的，T2和T3是从函数实参类型推断而来的</span></span><br><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);	<span class="comment">// long long sum(int, long)</span></span><br></pre></td></tr></table></figure>
<p><strong>尾置返回类型与类型转换</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 尾置返回允许我们在参数列表之后声明返回类型</span><br><span class="line">template &lt;typename It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">	// 处理序列</span><br><span class="line">	return *beg;	// 返回序列中一个元素的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时我们无法直接获得所需要的类型，比如上例中我们希望直接返回一个元素的值而非引用。此时可以用标准库的类型转换模板，在头文件<code>type_traits</code>中。<br>
上例可以改写为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 为了使用模板参数的成员，必须用typename，告知编译器type是一个类型</span><br><span class="line">template &lt;typename It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt;</span><br><span class="line">	typename remove_reference&lt;decltype(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">	// 处理序列</span><br><span class="line">	return *beg;	// 返回序列中的一个元素的拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/cpp_primer5_stl_template_type_transformation.jpg" alt="标准类型转换模板"></p>
<p><strong>函数指针和实参推断</strong><br>
用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf1指向实例int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="keyword">int</span> (*pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// func的重载版本；每个版本接受一个不同的函数指针类型</span><br><span class="line">void func(int(*)(const string&amp;, const string&amp;));</span><br><span class="line">void func(int(*)(const int&amp;, const int&amp;));</span><br><span class="line">func(compare&lt;int&gt;);	// 显式模板实参消除func调用的歧义</span><br></pre></td></tr></table></figure>
<p><strong>模板实参推断和引用</strong><br>
编译器会应用正常的引用绑定规则；const是底层的，不是顶层的。<br>
从左值引用函数参数推断类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>;	<span class="comment">// 实参必须是一个左值</span></span><br><span class="line"><span class="comment">// 对f1的调用使用实参所引用的类型作为模板参数类型</span></span><br><span class="line">f1(i);	<span class="comment">// i是一个int；模板参数类型T是int</span></span><br><span class="line">f1(ci);	<span class="comment">// ci是一个const int；模板参数类型T是const int</span></span><br><span class="line">f1(<span class="number">5</span>);	<span class="comment">// 错误：传递给一个&amp;参数的实参必须是一个左值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;	<span class="comment">// 可以接受一个右值</span></span><br><span class="line"><span class="comment">// f2中的参数是const&amp;；实参中的const是无关的</span></span><br><span class="line"><span class="comment">// 在每个调用中，f2的函数参数都被推断为const int&amp;</span></span><br><span class="line">f2(i);	<span class="comment">// i是一个int；模板参数T是int</span></span><br><span class="line">f2(ci);	<span class="comment">// ci是一个const int，但模板参数T是int</span></span><br><span class="line">f2(<span class="number">5</span>);	<span class="comment">// 一个const&amp;参数可以绑定到一个右值；T是int</span></span><br></pre></td></tr></table></figure>
<p>从右值引用函数参数推断类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line">f3(<span class="number">42</span>);	<span class="comment">// 实参是一个int类型的右值；模板参数T是int</span></span><br></pre></td></tr></table></figure>
<p>引用折叠和右值引用参数。<br>
一般来说不能将一个右值引用绑定到一个左值上。但是C++有两个例外规则。<br>
一，当我们将一个左值(如i)传递给函数的右值引用参数，且此右值引用指向模板类型参数(如T&amp;&amp;)时，编译器推断模板类型参数为实参的左值引用类型。<br>
二，如果我们间接创建一个引用的引用，则这些引用形成了折叠，饮用会折叠成一个普通的左值引用类型。<br>
例如X&amp; &amp;、X&amp; &amp;&amp;和X&amp;&amp; &amp;都折叠成类型X&amp;。类型X&amp;&amp; &amp;&amp;折叠成X&amp;&amp;。<br>
引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f3(i);	<span class="comment">// 实参是一个左值；模板参数T是int&amp;</span></span><br><span class="line">f3(ci);	<span class="comment">// 实参是一个左值；模板参数T是一个const int&amp;</span></span><br></pre></td></tr></table></figure>
<p>这两个规则导致了两个重要结果：</p>
<ul>
<li>如果一个函数参数是一个指向模板类型参数的右值引用(如T&amp;&amp;)，则它可以被绑定到一个左值；且</li>
<li>如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个(普通)左值引用参数(T&amp;)。</li>
</ul>
<p>这两个规则暗示，可以将任意类型的实参传递给T&amp;&amp;类型的函数参数。即，<br>
如果一个函数参数是指向模板参数类型的右值引用(如T&amp;&amp;)，则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用(如T&amp;)。</p>
<p>编写接受右值引用参数的模板函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp; val)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	T t = val;	<span class="comment">// 拷贝还是绑定一个引用？</span></span><br><span class="line">	t = fcn(t);	<span class="comment">// 赋值是只改变t还是既改变t又改变val?</span></span><br><span class="line">	<span class="keyword">if</span> (val == t) &#123;<span class="comment">/*...*/</span>&#125;	<span class="comment">// 若T是引用类型，则一直为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对一个右值(如字面常量42)调用f3，T为int，此时局部变量t的类型为int，且通过拷贝参数val的值被初始化。当我们对t赋值时，参数val保持不变。<br>
如果对一个左值(如i)调用f3，T为int&amp;，此时t的类型也为int&amp;，初始化被绑定到val。当我们对t赋值时，也同时改变了val的值。<br>
此时代码自然容易出错。<br>
使用右值引用的函数模板通常使用这种方式重载：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>;	<span class="comment">// 绑定到非const右值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;	<span class="comment">// 左值和const右值</span></span><br></pre></td></tr></table></figure>
<p><strong>理解std::move</strong><br>
标准库move函数是使用右值引用的模板的一个很好的例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在返回类型和类型转换中也要用到typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s1("hi"), s2;</span><br><span class="line">// T推断为string。实例化move&lt;string&gt;即string&amp;&amp; move(string &amp;&amp;t)，返回static_cast&lt;string&amp;&amp;&gt;(t)，t的类型已经是string&amp;&amp;，所以static_cast什么都不做。</span><br><span class="line">s2 = std::move(string("bye!"));	// 正确：从一个右值移动数据。</span><br><span class="line">// T推断为string&amp;。实例化move&lt;string&amp;&gt;即string&amp;&amp; move(string &amp;t)，返回static_cast&lt;string&amp;&amp;&gt;(t)，t的类型是string&amp;，static_cast将其转换为string&amp;&amp;。</span><br><span class="line">s2 = std::move(s1);	// 正确：但在赋值之后，s1的值是不确定的。</span><br></pre></td></tr></table></figure>
<p>从一个左值static_cast到一个右值引用是允许的。</p>
<p><strong>转发</strong><br>
某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质，包括实参类型是否是const的以及实参是左值还是右值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个可调用对象和另外两个参数的模板</span></span><br><span class="line"><span class="comment">// 对“翻转”的参数调用给定的可调用对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f, T1&amp;&amp; t1, T2&amp;&amp; t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	f(<span class="built_in">std</span>::forward&lt;T2&gt;(t2), <span class="built_in">std</span>::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个函数参数是指向模板类型参数的右值引用(如T&amp;&amp;)，它对应的实参的const属性和左值/右值属性将得到保持。<br>
当用于一个指向模板参数类型的右值引用函数参数(T&amp;&amp;)时，forward会保持实参类型的所有细节，定义在头文件utility中。<br>
与std::move相同，对std::forward不使用using声明是一个好主意。</p>
<h4 id="重载与模板"><a class="markdownIt-Anchor" href="#重载与模板"></a> 重载与模板</h4>
<p>函数模板可以被另一个模板或一个普通非模板函数重载。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印任何我们不能处理的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">ostringstream</span> ret;</span><br><span class="line">	ret &lt;&lt; t;	<span class="comment">// 使用T的输出运算符打印t的一个表示形式</span></span><br><span class="line">	<span class="keyword">return</span> ret.str();	<span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印指针的值，后跟指针指向的对象</span></span><br><span class="line"><span class="comment">// 注意：此函数不能用于char*</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(T* p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">ostringstream</span> ret;</span><br><span class="line">	ret &lt;&lt; <span class="string">"pointer: "</span> &lt;&lt; p;	<span class="comment">// 打印指针本身的值</span></span><br><span class="line">	<span class="keyword">if</span> (p)</span><br><span class="line">		ret &lt;&lt; <span class="string">" "</span> &lt;&lt; debug_rep(*p);	<span class="comment">// 打印p指向的值</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		ret &lt;&lt; <span class="string">" null pointer"</span>;	<span class="comment">// 或指出p为空</span></span><br><span class="line">	<span class="keyword">return</span> ret.str();	<span class="comment">// 返回ret绑定的string的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hi"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(s) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 只有第一个版本可用，因为s是非指针对象。</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(&amp;s) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 两个函数都可用，但第二个更精确，用第二个。</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span>* sp = &amp;s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(sp) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 两个都同样精确，但重载函数模板的特殊规则会选择最特例化的版本，即第二个。</span></span><br></pre></td></tr></table></figure>
<p>当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。<br>
对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对char*，将字符指针转换为string，并调用string版本的debug_reg</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">char</span>* p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> debug_rep(<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> debug_rep(<span class="built_in">string</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义任何函数之前，记得声明所有重载的函数版本。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(T* p)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="可变参数模板"><a class="markdownIt-Anchor" href="#可变参数模板"></a> 可变参数模板</h4>
<p>可变参数模板就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为参数包，模板参数包或函数参数包。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args是一个模板参数包；rest是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest表示零个或多个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T&amp; t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">double</span> d = <span class="number">3.14</span>; <span class="built_in">string</span> s = <span class="string">"how now brown cow"</span>;</span><br><span class="line">foo(i, s, <span class="number">42</span>, d);	<span class="comment">// 包里有三个参数</span></span><br><span class="line">foo(<span class="string">"hi"</span>);	<span class="comment">// 空包</span></span><br></pre></td></tr></table></figure>
<p>可以用<code>sizeof...</code>计算包中有多少元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Args ... args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 类型参数的数目</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编写可变参数函数模板</strong><br>
可变参数函数通常是递归的，需要写一个终止递归的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来终止递归并打印最后一个元素的函数</span></span><br><span class="line"><span class="comment">// 此函数必须在可变参数版本的print定义之前声明</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> T&amp; t)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; t;	<span class="comment">// 包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包中除了最后一个元素之外的其他元素都会调用这个版本的print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> T&amp; t, <span class="keyword">const</span> Args&amp;... rest)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	os &lt;&lt; t &lt;&lt; <span class="string">", "</span>;	<span class="comment">// 打印第一个实参</span></span><br><span class="line">	<span class="keyword">return</span> print(os, rest...);	<span class="comment">// 递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">print(<span class="built_in">cout</span>, i, s, <span class="number">42</span>);	<span class="comment">// 包中有两个参数</span></span><br></pre></td></tr></table></figure>
<p><strong>包扩展</strong><br>
扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。通过在模式右边放一个省略号…来触发扩展操作。<br>
扩展中的模式会独立地应用于包中的每个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在print调用中对每个实参调用debug_rep</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">errorMsg</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> Args&amp;... rest)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an)</span></span><br><span class="line">	<span class="keyword">return</span> print(os, debug_rep(rest)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>转发参数包</strong><br>
组合使用可变参数模板与forward机制来编写函数，实现将其实参不变地传递给其他函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> StrVec &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;..)</span></span>;</span><br><span class="line">	<span class="comment">// 其他成员的定义</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> StrVec::emplace_back(Args&amp;&amp;... args)</span><br><span class="line">&#123;</span><br><span class="line">	chk_n_alloc();	<span class="comment">// 如果需要的话重新分配StrVec内存空间</span></span><br><span class="line">	alloc.construct(first_free++, <span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模板特例化"><a class="markdownIt-Anchor" href="#模板特例化"></a> 模板特例化</h4>
<p>当不能或不希望使用模板版本时，可以定义类或函数模板的一个特例化版本。</p>
<p><strong>函数模板特例化</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 第一个版本；可以比较任意两个类型</span><br><span class="line">template &lt;typename T&gt; int compare(const T&amp;, const T&amp;);</span><br><span class="line">// 第二个版本处理字符串字面常量</span><br><span class="line">template &lt;size_t N, size_t M&gt;</span><br><span class="line">int compare(const char (&amp;)[N], const char (&amp;)[M]);</span><br><span class="line">// 使用</span><br><span class="line">const char *p1 = "hi", *p2 = "mom";</span><br><span class="line">compare(p1, p2);	// 调用第一个模板，因为无法将一个指针转换为一个数组的引用</span><br><span class="line">compare("hi", "mom");	// 调用有两个非类型参数的版本</span><br></pre></td></tr></table></figure>
<p>定义函数模板特例化，为字符数组的指针定义一个特例化的版本。<br>
为了指出我们正在实例化一个模板，应使用关键字template后跟一个空尖括号对(&lt;&gt;)。空尖括号指出我们将为原模板的所有模板参数提供实参。<br>
定义一个特例化版本时，函数参数类型必须与一个先前声明的模板中对应的类型匹配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特例化的本质是实例化一个模板，而非重载它。因此，特例化不影响函数匹配。<br>
模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。</p>
<p><strong>类模板特例化</strong><br>
例子：为标准库hash模板定义一个特例化版本，用来将Sales_data对象保存在无序容器中。<br>
必须在原模板定义所在的命名空间中特例化它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开std命名空间，以便特例化std::hash</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;	<span class="comment">// 定义一个特例化版本，模板参数为Sales_data</span></span><br><span class="line"><span class="keyword">struct</span> hash&lt;Sales_data&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 用来散列一个无序容器的类型必须要定义下列类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> result_type;</span><br><span class="line">	<span class="keyword">typedef</span> Sales_data argument_type;	<span class="comment">// 默认情况下，此类型需要==</span></span><br><span class="line">	<span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> Sales_data&amp; s) <span class="keyword">const</span>;</span><br><span class="line">	<span class="comment">// 我们的类使用合成的拷贝控制成员和默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> hash&lt;Sales_data&gt;::<span class="keyword">operator</span>()(<span class="keyword">const</span> Sales_data&amp; s) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(s.bookNo) ^ hash&lt;<span class="keyword">unsigned</span>&gt;()(s.units_sold) ^ hash&lt;<span class="keyword">double</span>&gt;()(s.revenue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;	<span class="comment">// 关闭std命名空间</span></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">unordered_multiset</span>&lt;Sales_data&gt; SDset;</span><br><span class="line"><span class="comment">// 由于hash&lt;Sales_data&gt;使用Sales_data的私有成员，需要将其声明为Sales_data的友元</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> <span class="built_in">std</span>::hash;	<span class="comment">// 友元声明所需要的</span></span><br><span class="line"><span class="keyword">class</span> Sales_data &#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="built_in">std</span>::hash&lt;Sales_data&gt;;</span><br><span class="line">	<span class="comment">// 其他</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了让Sales_data的用户能使用hash的特例化版本，应该在Sales_data的头文件中定义该特例化版本。</p>
<p><strong>类模板部分特例化</strong><br>
只能部分特例化类模板，不能部分特例化函数模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始的、最通用的版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct</span> remove_reference &#123;</span><br><span class="line">	<span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 部分特例化的版本，将用于左值引用和右值引用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct</span> remove_reference&lt;T&amp;&gt; <span class="comment">// 左值引用</span></span><br><span class="line">&#123;<span class="keyword">typedef</span> T type;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct</span> remove_reference&lt;T&amp;&amp;&gt;	<span class="comment">// 右值引用</span></span><br><span class="line">&#123;<span class="keyword">typedef</span> T type;&#125;;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">// decltype(42)为int，使用原始模板</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="number">42</span>)&gt;::type a;</span><br><span class="line"><span class="comment">// decltype(i)为int&amp;，使用第一个(T&amp;)部分特例化版本</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(i)&gt;::type b;</span><br><span class="line"><span class="comment">// decltype(std::move(i))为int&amp;&amp;，使用第二个(T&amp;&amp;)部分特例化版本</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="built_in">std</span>::move(i))&gt;::type c;</span><br></pre></td></tr></table></figure>
<p><strong>特例化类成员而不是整个类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> Foo &#123;</span><br><span class="line">	Foo(<span class="keyword">const</span> T &amp;t = T()) : mem(t) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">	T mem;</span><br><span class="line">	<span class="comment">// Foo的其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;	<span class="comment">// 我们正在特例化一个模板</span></span><br><span class="line"><span class="keyword">void</span> Foo&lt;<span class="keyword">int</span>&gt;::Bar()	<span class="comment">// 我们正在特例化Foo&lt;int&gt;的成员Bar</span></span><br><span class="line">&#123;<span class="comment">/*anything*/</span>&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Foo&lt;<span class="built_in">string</span>&gt; fs;	<span class="comment">// 实例化Foo&lt;string&gt;::Foo()</span></span><br><span class="line">fs.Bar();	<span class="comment">// 实例化Foo&lt;string&gt;::Bar()</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;	<span class="comment">// 实例化Foo&lt;int&gt;::Foo()</span></span><br><span class="line">fi.Bar();	<span class="comment">// 使用我们的特例化版本Foo&lt;int&gt;::Bar()</span></span><br></pre></td></tr></table></figure>
<hr>
<p>跨时6月才完成，饱含泪花(˘̩̩̩ε˘̩ƪ)</p>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">博文</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#类设计者的工具"><span class="toc-number">1.</span> <span class="toc-text"> 类设计者的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#拷贝控制"><span class="toc-number">1.1.</span> <span class="toc-text"> 拷贝控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#拷贝-赋值与销毁"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 拷贝、赋值与销毁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#拷贝控制和资源管理"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 拷贝控制和资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#行为像值的类"><span class="toc-number">1.1.2.1.</span> <span class="toc-text"> 行为像值的类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#行为像指针的类"><span class="toc-number">1.1.2.2.</span> <span class="toc-text"> 行为像指针的类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#交换操作"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 交换操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态内存管理类"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 动态内存管理类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象移动"><span class="toc-number">1.1.5.</span> <span class="toc-text"> 对象移动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重载运算与类型转换"><span class="toc-number">1.2.</span> <span class="toc-text"> 重载运算与类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本概念"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输入和输出运算符"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 输入和输出运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#算术和关系运算符"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 算术和关系运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#赋值运算符"><span class="toc-number">1.2.4.</span> <span class="toc-text"> 赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#下标运算符"><span class="toc-number">1.2.5.</span> <span class="toc-text"> 下标运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#递增和递减运算符"><span class="toc-number">1.2.6.</span> <span class="toc-text"> 递增和递减运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#成员访问运算符"><span class="toc-number">1.2.7.</span> <span class="toc-text"> 成员访问运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数调用运算符"><span class="toc-number">1.2.8.</span> <span class="toc-text"> 函数调用运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重载-类型转换与运算符"><span class="toc-number">1.2.9.</span> <span class="toc-text"> 重载、类型转换与运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象程序设计"><span class="toc-number">1.3.</span> <span class="toc-text"> 面向对象程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#oop概述"><span class="toc-number">1.3.1.</span> <span class="toc-text"> OOP：概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义基类和派生类"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 定义基类和派生类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚函数"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 虚函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#抽象基类"><span class="toc-number">1.3.4.</span> <span class="toc-text"> 抽象基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#访问控制与继承"><span class="toc-number">1.3.5.</span> <span class="toc-text"> 访问控制与继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继承中的类作用域"><span class="toc-number">1.3.6.</span> <span class="toc-text"> 继承中的类作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数与拷贝控制"><span class="toc-number">1.3.7.</span> <span class="toc-text"> 构造函数与拷贝控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#容器与继承"><span class="toc-number">1.3.8.</span> <span class="toc-text"> 容器与继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板与泛型编程"><span class="toc-number">1.4.</span> <span class="toc-text"> 模板与泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义模板"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 定义模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模板实参推断"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 模板实参推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重载与模板"><span class="toc-number">1.4.3.</span> <span class="toc-text"> 重载与模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可变参数模板"><span class="toc-number">1.4.4.</span> <span class="toc-text"> 可变参数模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模板特例化"><span class="toc-number">1.4.5.</span> <span class="toc-text"> 模板特例化</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/&text=C++ Primer, 5th Edition 笔记3"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/&title=C++ Primer, 5th Edition 笔记3"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/&is_video=false&description=C++ Primer, 5th Edition 笔记3"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++ Primer, 5th Edition 笔记3&body=Check out this article: http://conglang.github.io/2015/06/23/note-cpp-primer5-3/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/&title=C++ Primer, 5th Edition 笔记3"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/&title=C++ Primer, 5th Edition 笔记3"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/&title=C++ Primer, 5th Edition 笔记3"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/&title=C++ Primer, 5th Edition 笔记3"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://conglang.github.io/2015/06/23/note-cpp-primer5-3/&name=C++ Primer, 5th Edition 笔记3&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2018 聪
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">博文</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>

<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/fontawesome-all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-74786593-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

    <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?4e074986ce7bd4c6c94338ce1a49c4be";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

<!-- Disqus Comments -->



