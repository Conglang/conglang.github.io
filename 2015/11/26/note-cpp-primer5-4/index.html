<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="C++ Primer, 5th Edition的第四部分：高级主题的笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer, 5th Edition 笔记4">
<meta property="og:url" content="http://conglang.github.io/2015/11/26/note-cpp-primer5-4/index.html">
<meta property="og:site_name" content="A Stellar Hiker">
<meta property="og:description" content="C++ Primer, 5th Edition的第四部分：高级主题的笔记。">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_tuple.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_regex.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_regexsearch_regexmatch.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_regex_wregex_options.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_regex_error_type.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_regex_type.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_sregex_iterator.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_smatch_operation.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_sub_match_opt.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_regex_replace.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_match_flag_type.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_random_engine.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_distribution.jpg">
<meta property="og:image" content="http://conglang.github.io/img/cpp_primer5_exception_class_structure.jpg">
<meta property="og:updated_time" content="2018-07-03T15:46:49.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ Primer, 5th Edition 笔记4">
<meta name="twitter:description" content="C++ Primer, 5th Edition的第四部分：高级主题的笔记。">
<meta name="twitter:image" content="http://conglang.github.io/img/cpp_primer5_tuple.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/astro.png">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/astro.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/astro.png">
          
        
    
    <!-- title -->
    <title>C++ Primer, 5th Edition 笔记4</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
  	<link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet">
</head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">博文</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2016/01/20/simple-vba/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2015/09/20/note-crucial-conversations/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/&text=C++ Primer, 5th Edition 笔记4"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/&title=C++ Primer, 5th Edition 笔记4"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/&is_video=false&description=C++ Primer, 5th Edition 笔记4"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++ Primer, 5th Edition 笔记4&body=Check out this article: http://conglang.github.io/2015/11/26/note-cpp-primer5-4/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/&title=C++ Primer, 5th Edition 笔记4"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/&title=C++ Primer, 5th Edition 笔记4"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/&title=C++ Primer, 5th Edition 笔记4"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/&title=C++ Primer, 5th Edition 笔记4"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/&name=C++ Primer, 5th Edition 笔记4&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#高级主题"><span class="toc-number">1.</span> <span class="toc-text"> 高级主题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#标准库特殊设施"><span class="toc-number">1.1.</span> <span class="toc-text"> 标准库特殊设施</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tuple类型"><span class="toc-number">1.1.1.</span> <span class="toc-text"> tuple类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bitset类型"><span class="toc-number">1.1.2.</span> <span class="toc-text"> bitset类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#正则表达式"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#随机数"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 随机数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io库再探"><span class="toc-number">1.1.5.</span> <span class="toc-text"> IO库再探</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用于大型程序的工具"><span class="toc-number">1.2.</span> <span class="toc-text"> 用于大型程序的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#异常处理"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命名空间"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 命名空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多重继承与虚继承"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 多重继承与虚继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特殊工具与技术"><span class="toc-number">1.3.</span> <span class="toc-text"> 特殊工具与技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#控制内存分配"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 控制内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行时类型识别"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 运行时类型识别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#枚举类型"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 枚举类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类成员指针"><span class="toc-number">1.3.4.</span> <span class="toc-text"> 类成员指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#嵌套类"><span class="toc-number">1.3.5.</span> <span class="toc-text"> 嵌套类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#union一种节省空间的类"><span class="toc-number">1.3.6.</span> <span class="toc-text"> union：一种节省空间的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#局部类"><span class="toc-number">1.3.7.</span> <span class="toc-text"> 局部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#固有的不可移植的特性"><span class="toc-number">1.3.8.</span> <span class="toc-text"> 固有的不可移植的特性</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        C++ Primer, 5th Edition 笔记4
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">A Stellar Hiker</span>
      </span>
      
    <div class="postdate">
        <time datetime="2015-11-26T14:22:39.000Z" itemprop="datePublished">2015-11-26</time>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Book/">Book</a>, <a class="tag-link" href="/tags/C/">C++</a>, <a class="tag-link" href="/tags/STL/">STL</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>终于补全了3的博文( ＴДＴ)可以开4了。<br>
歹势啦。一本书拖了6个月还没整理完。</p>
<hr>
<h2 id="高级主题"><a class="markdownIt-Anchor" href="#高级主题"></a> 高级主题</h2>
<h3 id="标准库特殊设施"><a class="markdownIt-Anchor" href="#标准库特殊设施"></a> 标准库特殊设施</h3>
<h4 id="tuple类型"><a class="markdownIt-Anchor" href="#tuple类型"></a> tuple类型</h4>
<p>turple是类似pair的模板。每个确定的tuple类型的成员数目是固定的，但一个tuple类型的成员数目可以与另一个tuple类型不同。<br>
当希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，tuple很有用。<br>
可以将tuple看作一个“快速而随意”的数据结构。<br>
<img src="/img/cpp_primer5_tuple.jpg" alt="tuple支持的操作"></p>
<p><strong>定义和初始化tuple</strong><br>
可以使用默认构造函数，或显式直接初始化，或使用make_tuple。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD;	<span class="comment">// 三个成员都设置为0</span></span><br><span class="line">tuple&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;, <span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; someVal(<span class="string">"constants"</span>, &#123;<span class="number">3.14</span>, <span class="number">2.718</span>&#125;, <span class="number">42</span>, &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</span><br><span class="line"><span class="keyword">auto</span> item = make_tuple(<span class="string">"0-999-78345-X"</span>, <span class="number">3</span>, <span class="number">20.00</span>);</span><br></pre></td></tr></table></figure>
<p>访问tuple的成员需要使用一个名为get的标准库函数模板，从0开始计数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> book = get&lt;<span class="number">0</span>&gt;(item);	<span class="comment">// 返回item的第一个成员</span></span><br><span class="line"><span class="keyword">auto</span> cnt = get&lt;<span class="number">1</span>&gt;(item);	<span class="comment">// 返回item的第二个成员</span></span><br><span class="line"><span class="keyword">auto</span> price = get&lt;<span class="number">2</span>&gt;(item)/cnt;	<span class="comment">// 返回item的最后一个成员</span></span><br><span class="line">get&lt;<span class="number">2</span>&gt;(item) *= <span class="number">0.8</span>;	<span class="comment">// 打折20%</span></span><br></pre></td></tr></table></figure>
<p>查询tuple成员的数量和类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef decltype(item) trans;	// trans是item的类型</span><br><span class="line">// 返回trans类型对象中的成员的数量</span><br><span class="line">size_t sz = tuple_size&lt;trans&gt;::value;	// 返回3</span><br><span class="line">// cnt的类型与item中第二个成员相同</span><br><span class="line">tuple_element&lt;1, trans&gt;::type cnt = get&lt;1&gt;(item);	// cnt是一个int</span><br></pre></td></tr></table></figure>
<p>关系和相等运算符。比较的两侧必须具有相同数量的成员，且每对成员间的比较是合法的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; duo(<span class="string">"1"</span>, <span class="string">"2"</span>);</span><br><span class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; twoD(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">bool</span> b = (duo == twoD);	<span class="comment">// 错误：不能比较size_t和string</span></span><br><span class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; threeD(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">b = (twoD &lt; threeD);	<span class="comment">// 错误：成员数量不同</span></span><br><span class="line">tuple&lt;<span class="keyword">size_t</span>, <span class="keyword">size_t</span>&gt; origin(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">b = (origin &lt; twoD);	<span class="comment">// 正确：b为true</span></span><br></pre></td></tr></table></figure>
<p>由于tuple定义了&lt;和==运算符，可以将tuple序列传递给算法，并且可以在无序容器中将tuple作为关键字类型。</p>
<p><strong>使用tuple返回多个值</strong><br>
tuple的一个常见用途是从一个函数返回多个值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// matches有三个成员：一家书店的索引和两个指向书店vector中元素的迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;<span class="built_in">vector</span>&lt;Sales_data&gt;::size_type, <span class="built_in">vector</span>&lt;Sales_data&gt;::const_iterator, <span class="built_in">vector</span>&lt;Sales_data&gt;::const_iterator&gt; matches;</span><br><span class="line"><span class="comment">// files保存每家书店的销售记录</span></span><br><span class="line"><span class="comment">// findBook返回一个vector，每家销售了给定书籍的书店都在其中有一项</span></span><br><span class="line"><span class="built_in">vector</span>&lt;matches&gt; findBook(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Sales_data&gt;&gt;&amp; files, <span class="keyword">const</span> <span class="built_in">string</span>&amp; book)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;matches&gt; ret;	<span class="comment">// 初始化为空vector</span></span><br><span class="line">	<span class="comment">// 对每家书店，查找与给定书籍匹配的记录范围(如果存在的话)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = files.cbegin(); it != files.cend(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 查找具有相同ISBN的Sales_data范围</span></span><br><span class="line">		<span class="keyword">auto</span> found = equal_range(it-&gt;cbegin(), it-&gt;cend(), book, compareIsbn);</span><br><span class="line">		<span class="keyword">if</span> (found.first != found.second)	<span class="comment">// 此书店销售了给定书籍</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 记住此书店的索引及匹配的范围</span></span><br><span class="line">			ret.push_back(make_tuple(it - files.cbegin(), found.first, found.second));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;	<span class="comment">// 如果未找到匹配记录的话，ret为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用函数返回的tuple</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reportResults</span><span class="params">(istream&amp; in, ostream&amp; os, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Sales_data&gt;&gt;&amp; files)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s;	<span class="comment">// 要查找的书</span></span><br><span class="line">	<span class="keyword">while</span> (in &gt;&gt; s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> trans = findBook(files, s);	<span class="comment">// 销售了这本书的书店</span></span><br><span class="line">		<span class="keyword">if</span> (trans.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" not found in any stores"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;	<span class="comment">// 获得下一本要查找的书</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; store : trans)	<span class="comment">// 对每家销售了给定书籍的书店</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// get&lt;n&gt;返回store中tuple的指定的成员</span></span><br><span class="line">			os &lt;&lt; <span class="string">"store"</span> &lt;&lt; get&lt;<span class="number">0</span>&gt;(store) &lt;&lt; <span class="string">" sales: "</span></span><br><span class="line">				&lt;&lt; accumulate(get&lt;<span class="number">1</span>&gt;(store), get&lt;<span class="number">2</span>&gt;(store), Sales_data(s))</span><br><span class="line">				&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bitset类型"><a class="markdownIt-Anchor" href="#bitset类型"></a> bitset类型</h4>
<p>参看之前整理的<a href="/2014/12/24/bit-manipulation/#STL%E4%B8%AD%E7%9A%84bitset%E7%B1%BB%E5%9E%8B">STL中的bitset类型</a>。</p>
<h4 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h4>
<p>介绍如何使用C++正则表达式库(RE库)，是新标准库的一部分，定义在<code>regex</code>中。<br>
<img src="/img/cpp_primer5_regex.jpg" alt="正则表达式库组件"><br>
<img src="/img/cpp_primer5_regexsearch_regexmatch.jpg" alt="regex_search和regex_match的参数"></p>
<p><strong>使用正则表达式库</strong><br>
一个例子：查找违反规则“i除非在c之后，否则必须在e之前”的单词，程序输出是freind。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找不在字符c之后的字符串ei</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">pattern</span><span class="params">(<span class="string">"[^c]ei"</span>)</span></span>;</span><br><span class="line"><span class="comment">// 我们需要包含pattern的整个单词</span></span><br><span class="line">pattern = <span class="string">"[[:alpha:]]*"</span> + pattern + <span class="string">"[[:alpha:]]*"</span>;</span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(pattrn)</span></span>;	<span class="comment">// 构造一个用于查找模式的regex</span></span><br><span class="line">smatch results;	<span class="comment">// 定义一个对象保存搜索结果</span></span><br><span class="line"><span class="comment">// 定义一个string保存与模式匹配和不匹配的文本</span></span><br><span class="line"><span class="built_in">string</span> test_str = <span class="string">"receipt freind theif receive"</span>;</span><br><span class="line"><span class="comment">// 用r在test_str中查找与pattern匹配的子串</span></span><br><span class="line"><span class="keyword">if</span> (regex_search(test_str, results, r))	<span class="comment">// 如果有匹配子串</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; results.str() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 打印匹配的单词</span></span><br></pre></td></tr></table></figure>
<p>可以指定一些标志来控制regex对象的处理过程。<br>
<img src="/img/cpp_primer5_regex_wregex_options.jpg" alt="regex(和wregex)选项"><br>
例子：识别不分大小写的文件扩展名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个或多个字母或数字字符后接一个'.'再接"cpp"或"cxx"或"cc"</span></span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(<span class="string">"[[:alnum:]]+\\.(cpp|cxx|cc)$"</span>, regex::icase)</span></span>;</span><br><span class="line">smatch results;</span><br><span class="line"><span class="built_in">string</span> filename;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; filename)</span><br><span class="line">	<span class="keyword">if</span> (regex_search(filename, results, r))</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; results.str() &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 打印匹配结果</span></span><br></pre></td></tr></table></figure>
<p>一个正则表达式的语法是否正确是在运行时解析的。有错误时会抛出一个regex_error类型的异常。<br>
<img src="/img/cpp_primer5_regex_error_type.jpg" alt="正则表达式错误类型"><br>
避免创建不必要的正则表达式，正则表达式的编译是一个非常慢的操作。</p>
<p>正则表达式RE库类型必须与输入序列类型匹配。<br>
<img src="/img/cpp_primer5_regex_type.jpg" alt="正则表达式库类"></p>
<p><strong>匹配与Regex迭代器类型</strong><br>
sregex_iterator可以遍历匹配结果。如前所述，每种不同输入序列类型都有对应的特殊regex迭代器类型。<br>
<img src="/img/cpp_primer5_sregex_iterator.jpg" alt="sregex_iterator操作"><br>
例子，扩展之前程序。假定名为file的string保存了我们要搜索的输入文件的全部内容。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 查找前一个字符不是c的字符串ei</span><br><span class="line">string pattern("[^c]ei");</span><br><span class="line">// 我们想要包含pattern的整个单词</span><br><span class="line">pattern = "[[:alpha:]]*" + pattern + "[[:alpha:]]*";</span><br><span class="line">regex r(pattrn, regex::icase);	// 在进行匹配时将忽略大小写</span><br><span class="line">// 它将反复调用regex_search来寻找文件中的所有匹配</span><br><span class="line">for (sregex_iterator it(file.begin(), file.end(), r), end_it; it != end_it; ++it)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; it-&gt;str() &lt;&lt; endl;	// 匹配的单词</span><br><span class="line">	auto pos = it-&gt;prefix().length();	// 前缀的大小</span><br><span class="line">	pos = pos &gt; 40 ? pos - 40 : 0;	// 我们想要最多40个字符</span><br><span class="line">	cout &lt;&lt; it-&gt;prefix().str().substr(pos)	// 前缀的最后一部分</span><br><span class="line">		&lt;&lt; "\n\t\t&gt;&gt;&gt; " &lt;&lt; it-&gt;str() &lt;&lt; " &lt;&lt;&lt;\n"	// 匹配的单词</span><br><span class="line">		&lt;&lt; it-&gt;suffix().str().substr(0, 40)	// 后缀的第一部分</span><br><span class="line">		&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/cpp_primer5_smatch_operation.jpg" alt="smatch操作"></p>
<p><strong>使用子表达式</strong><br>
正则表达式语法通常用括号表示子表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r有两个子表达式：第一个是点之前表示文件名的部分，第二个表示文件扩展名</span></span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(<span class="string">"([[:alnum:]]+)\\.(cpp|cxx|cc)$"</span>, regex::icase)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以改写上上例，使之只打印文件名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (regex_search(filename, results, r))</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; results.str(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 打印第一个子表达式</span></span><br></pre></td></tr></table></figure>
<p>子表达式的常见用途是验证必须匹配特定格式的数据。<br>
<img src="/img/cpp_primer5_sub_match_opt.jpg" alt="子匹配操作"><br>
例子：匹配美国电话号码。<br>
<code>(\\()?</code>表示区号部分可选的左括号。<code>(\\d{3})</code>表示区号。<code>(\\))?</code>表示区号部分可选的右括号。<code>([-. ])?</code>表示可选的分隔符。<code>(\\d{3})</code>表示号码的下三位数字。<code>([-. ])?</code>表示可选的分隔符。<code>(\\d{4})</code>表示号码的最后四位数字。<br>
例子：读取一个文件，并用此模式查找与完整的电话号码模式匹配的数据，然后调用一个valid函数检查号码格式是否合法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">string phone = "(\\()?(\\d&#123;3&#125;)(\\))?([-. ])?(\\d&#123;3&#125;)([-. ])?(\\d&#123;4&#125;)";</span><br><span class="line">regex r(phone);	// regex对象，用于查找我们的模式</span><br><span class="line">smatch m;</span><br><span class="line">string s;</span><br><span class="line">// 从输入文件中读取每条记录</span><br><span class="line">while (getline(cin, s))</span><br><span class="line">&#123;</span><br><span class="line">	// 对每个匹配的电话号码</span><br><span class="line">	for (sregex_iterator it(s.begin(), s.end(), r), end_it; it != end_it; ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		// 检查号码的格式是否合法</span><br><span class="line">		if (valid(*it))</span><br><span class="line">			cout &lt;&lt; "valid: " &lt;&lt; it-&gt;str() &lt;&lt; endl;</span><br><span class="line">		else</span><br><span class="line">			cout &lt;&lt; "not valid: " &lt;&lt; it-&gt;str() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 我们的pattern有七个子表达式，所以smatch对象会包含8个ssub_match元素，位置0的元素表示整个匹配，元素1-7表示每个对应的子表达式</span><br><span class="line">// 区号应该要么完整括号包围的，要么完全没有括号</span><br><span class="line">bool valid(const smatch&amp; m)</span><br><span class="line">&#123;</span><br><span class="line">	// 如果区号前有一个左括号</span><br><span class="line">	if (m[1].matched)</span><br><span class="line">		// 则区号后必须有一个右括号，之后紧跟剩余号码或一个空格</span><br><span class="line">		return m[3].matched &amp;&amp; (m[4].matched == 0 || m[4].str() == " ");</span><br><span class="line">	else</span><br><span class="line">	// 否则，区号不能有右括号</span><br><span class="line">	// 另两个组成部分间的分隔符必须匹配</span><br><span class="line">		return !m[3].matched &amp;&amp; m[4].str() == m[6].str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用regex_replace</strong><br>
在输入序列中查找并替换一个正则表达式时，用regex_replace。<br>
用一个符号<code>$</code>后跟子表达式的索引号来表示一个特定的子表达式。<br>
<img src="/img/cpp_primer5_regex_replace.jpg" alt="正则表达式替换操作"><br>
例子：替换一个大文件中的电话号码。<br>
将<br>
morgan (111) 111-1111 111-111-1111<br>
drew (111)111.1111<br>
lee (111) 111-1111 1111111111 111.111-1111<br>
转换为：<br>
morgan 111.111.1111 111.111.1111<br>
drew 111.111.1111<br>
lee 111.111.1111 111.111.1111 111.111.1111</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> phone = <span class="string">"(\\()?(\\d&#123;3&#125;)(\\))?([-. ])?(\\d&#123;3&#125;)([-. ])?(\\d&#123;4&#125;)"</span>;</span><br><span class="line">	<span class="function">regex <span class="title">r</span><span class="params">(phone)</span></span>;	<span class="comment">// 寻找模式所用的regex对象</span></span><br><span class="line">	smatch m;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">string</span> fmt = <span class="string">"$2.$5.$7"</span>;	<span class="comment">// 将号码格式改为ddd.ddd.dddd</span></span><br><span class="line">	<span class="comment">// 从输入文件中读取每条记录</span></span><br><span class="line">	<span class="keyword">while</span> (getline(<span class="built_in">cin</span>,s))</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; regex_replace(s,r,fmt) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准库定义了用来在替换过程中控制匹配或格式的标志。这些标志可以传递给函数regex_search或regex_match或是类smatch的format成员。<br>
<img src="/img/cpp_primer5_match_flag_type.jpg" alt="匹配标志"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只生成电话号码：使用新的格式字符串</span></span><br><span class="line"><span class="built_in">string</span> fmt2 = <span class="string">"$2.$5.$7 "</span>;	<span class="comment">// 在最后一部分号码后放置空格作为分隔符</span></span><br><span class="line"><span class="comment">// 通知regex_replace只拷贝它替换的文本</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; regex_replace(s, r, fmt2, format_no_copy) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>此版本的程序生成：<br>
111.111.1111 111.111.1111<br>
111.111.1111<br>
111.111.1111 111.111.1111 111.111.1111</p>
<h4 id="随机数"><a class="markdownIt-Anchor" href="#随机数"></a> 随机数</h4>
<p>从C++11开始，头文件random中定义了随机数库，包括随机数引擎类和随机数分布类。</p>
<table>
<thead>
<tr>
<th></th>
<th>随机数库的组成</th>
</tr>
</thead>
<tbody>
<tr>
<td>引擎</td>
<td>类型，生成随机unsigned整数序列</td>
</tr>
<tr>
<td>分布</td>
<td>类型，使用引擎返回服从特定概率分布的随机数</td>
</tr>
</tbody>
</table>
<p>C++程序不应该使用库函数rand，而应使用default_random_engine类和恰当的分布类对象。</p>
<p><strong>随机数引擎和分布</strong><br>
随机数引擎是函数对象类，其()运算符返回一个随机unsigned整数。<br>
标准库定义了多个随机数引擎类，区别在于性能和随机性质量不同。每个编译器都会指定其中一个作为default_random_engine类型。<br>
<img src="/img/cpp_primer5_random_engine.jpg" alt="随机数引擎操作"><br>
直接用引擎生成的输出的值范围通常与我们的需要不符。需要使用分布类型的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成0到9之间(包含)均匀分布的随机数</span></span><br><span class="line">uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; u(<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">default_random_engine e;	<span class="comment">// 生成无符号随机整数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	<span class="comment">// 将u作为随机数源</span></span><br><span class="line">	<span class="comment">// 每个调用返回在指定范围内并服从均匀分布的值</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; u(e) &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></table></figure>
<p>随机数发生器是分布对象和引擎对象的组合。<br>
注意一个给定的随机数发生器一直会生成相同的随机数序列。一个函数如果定义了局部的随机数发生器，应该将其(包括引擎和分布对象)定义为static的。否则，每次调用函数都会生成相同的序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个vector，包含100个均匀分布的随机数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; good_randVec()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 由于我们希望引擎和分布对象保持状态，因此应该将它们</span></span><br><span class="line">	<span class="comment">// 定义成static的，从而每次调用都生成新的数</span></span><br><span class="line">	<span class="keyword">static</span> default_random_engine e;</span><br><span class="line">	<span class="keyword">static</span> uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; u(<span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; ret;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">		ret.push_back(u(e));</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以设置随机数发生器种子。在创建引擎对象时提供种子，或者调用引擎的seed成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">default_random_engine <span class="title">e1</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">default_random_engine e2;</span><br><span class="line">e2.seed(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>time返回以秒计的时间，这种方式只适用于生成种子的间隔为秒级或者更长的应用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e1(time(0));	// 稍微随机些的种子</span><br></pre></td></tr></table></figure>
<p><strong>其他随机数分布</strong><br>
C++11标准库定义了20种分布类型，这里未列举。<br>
<img src="/img/cpp_primer5_distribution.jpg" alt="分布类型的操作"><br>
生成随机浮点数用<code>uniform_real_distribution</code>。如<code>uniform_real_distribution&lt;double&gt; u(0,1);</code>。<br>
使用分布的默认结果类型<code>uniform_real_distribution&lt;&gt; u(0,1);//默认生成double值</code>。<br>
生成非均匀分布的随机数<code>normal_distribution&lt;&gt; n(4,1.5);//均值4，标准差1.5</code>。<br>
总返回一个bool值，返回true的概率是一个常数，默认是0.5.<code>bernoulli_distribution b;</code><br>
注意引擎和分布要在循环外定义，不然每次创建一个新引擎，会生成相同的值。</p>
<h4 id="io库再探"><a class="markdownIt-Anchor" href="#io库再探"></a> IO库再探</h4>
<p>P666 不喜欢IO库，以后再说。</p>
<h3 id="用于大型程序的工具"><a class="markdownIt-Anchor" href="#用于大型程序的工具"></a> 用于大型程序的工具</h3>
<p>异常处理、命名空间、多重继承正好分别处理这些需求：</p>
<ul>
<li>在独立开发的子系统之间协同处理错误的能力。</li>
<li>使用各种库(可能包含独立开发的库)进行协同开发的能力。</li>
<li>对比较复杂的应用概念建模的能力。</li>
</ul>
<h4 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h4>
<p>异常处理机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并作出相应的处理。</p>
<p><strong>抛出异常</strong><br>
在C++中，通过抛出throw一条表达式来引发raise一个异常。被抛出的表达式类型以及当前的调用链共同决定了哪段处理代码handler将被用来处理该异常。被选中的处理代码是在当前调用链中与抛出对象类型匹配的最近的处理代码。<br>
当执行一个throw时，跟在throw后面的语句将不再被执行。程序的控制权从throw转移到与之匹配的catch模块。这意味着：沿着调用链的函数可能会提早退出；一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁。<br>
栈展开stack unwinding过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch字句为止；也可能一直没找到匹配的catch，则退出主函数后查找过程终止。<br>
假设找到了一个匹配的catch子句，则程序进入该子句并执行其中的代码。当执行完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里继续执行。如果没有找到匹配的catch子句，程序将退出。<br>
在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。<br>
当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象exception object的类型。注意。如果一条throw表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分，只有基类部分被抛出。<br>
抛出指针要求在任何对应的处理代码存在的地方，指针所指向的对象都必须存在。</p>
<p><strong>捕获异常</strong><br>
catch子句的异常声明的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型，可以是左值引用，但不能是右值引用。<br>
异常声明的静态类型将决定catch语句所能执行的操作。如果catch的参数是基类类型，则catch无法使用派生类特有的任何成员。<br>
通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch的参数定义成引用类型。<br>
查找匹配的catch语句的过程中，第一个与异常匹配的catch语句将被选中，所以越是专门的catch越是应该置于整个catch列表的前端，同理继承链最底层的类的catch也应该放在前面。<br>
有时一个单独的catch语句不能完整地处理某个异常。执行了某些校正工作之后，单签的catch可以重新抛出rethrowing将异常传递给另外一个catch语句。<code>throw;</code>。空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内，如果在处理代码之外的区域遇到了空throw语句，编译器将调用terminate。<br>
<code>catch(...)</code>可以捕获所有异常的语句，常与重新抛出语句一起使用。</p>
<p><strong>函数try语句块与构造函数</strong><br>
要想处理构造函数初始值抛出的异常，必须将构造函数写成函数try语句块。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; il) <span class="keyword">try</span></span><br><span class="line">	: data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;(il))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// something</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::bad_alloc&amp; e)</span><br><span class="line">&#123;handle_out_of_memory(e);&#125;</span><br></pre></td></tr></table></figure>
<p>可以处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常。</p>
<p><strong>noexcept异常说明</strong><br>
知道函数不会抛出异常有助于简化调用该函数的代码。如果编译器确认函数不会抛出异常，就能执行某些特殊的优化操作。<br>
关键字<code>noexcept</code>紧跟在函数的参数列表后面。还可以有一个可选的实参，该实参必须能转换为bool类型。和可以作为运算符表示给定的表达式是否会抛出异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoup</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">noexcept</span></span>;	<span class="comment">// 不会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloc</span><span class="params">(<span class="keyword">int</span>)</span></span>;	<span class="comment">// 可能抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoup</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>;	<span class="comment">// recoup不会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloc</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;	<span class="comment">// alloc可能抛出异常</span></span><br><span class="line"><span class="keyword">noexcept</span>(recoup(i));	<span class="comment">// 如果recoupt不抛出异常则结果为true</span></span><br></pre></td></tr></table></figure>
<p>noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该说明应该在函数的尾置返回类型之前。也可以在函数指针的声明和定义中指定noexcept。不能再typedef或类型别名中出现noexcept。在成员函数中，noexcept说明符需要跟在const及引用限定符之后，而在final、override或虚函数的=0之前。<br>
编译器不能也不必在编译时验证异常说明。</p>
<p>异常说明与指针、虚函数和拷贝控制。<br>
函数指针及该指针所指的函数必须具有一致的异常说明。不抛出的找不抛出的，可能抛出的谁都行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recoupt和pf1都承诺不会抛出异常</span></span><br><span class="line"><span class="keyword">void</span> (*pf1)(<span class="keyword">int</span>) <span class="keyword">noexcept</span> = recoup;</span><br><span class="line"><span class="keyword">void</span> (*pf2)(<span class="keyword">int</span>) = recoup;	<span class="comment">// 正确：recoup不会抛出异常，pf2可能抛出异常，两者之间互不干扰</span></span><br><span class="line">pf1 = alloc;	<span class="comment">// 错误：alloc可能抛出异常，但是pf1已经说明了它不会抛出异常</span></span><br><span class="line">pf2 = alloc;	<span class="comment">// 正确：pf2和alloc都可能抛出异常</span></span><br></pre></td></tr></table></figure>
<p>如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出相同的承诺。与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出异常，也可以不允许抛出异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span>)</span> <span class="keyword">noexcept</span></span>;	<span class="comment">// 不会抛出异常</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;	<span class="comment">// 可能抛出异常</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;	<span class="comment">// 可能抛出异常</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Derived &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span>)</span></span>;	<span class="comment">// 错误：Base::f1承诺不会抛出异常</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;	<span class="comment">// 正确：与Base::f2的异常说明一致</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;	<span class="comment">// 正确：Derived的f2做了更严格的限定，这是允许的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当编译器合成拷贝控制成员时，同时也生成一个异常说明。如果对所有成员和基类的所有操作都承诺了不会抛出异常，则合成的成员时noexcept的；否则就是noexcept(false)的。</p>
<p><strong>异常类层次</strong><br>
<img src="/img/cpp_primer5_exception_class_structure.jpg" alt="标准exception类层次"><br>
定义我们自己的异常类。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class out_of_stock : public std::runtime_error</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	explicit out_of_stock(const std::string&amp; s) : std::runtime_error(s)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class isbn_mismatch : public std::logic_error</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	explicit isbn_mismatch(const std::string&amp; s) : std::logic_error(s)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	isbn_mismatch(const std::string&amp; s, const std::string&amp; lhs, const std::string&amp; rhs)</span><br><span class="line">	: std::logic_error(s), left(lhs), right(rhs)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	const std::string left, right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果参与加法的两个对象并非同一书籍，则抛出一个异常</span></span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sales_data&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (isbn() != rhs.isbn())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> isbn_mismatch(<span class="string">"wrong isbns"</span>, isbn(), rhs.isbn());</span><br><span class="line">	&#125;</span><br><span class="line">	units_sold += rhs.units_sold;</span><br><span class="line">	revenue += rhs.revenue;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用之前设定的书店程序异常类</span></span><br><span class="line">Sales_data item1, item2, sum;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2)	<span class="comment">// 读取两条交易信息</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		sum = item1 + item2;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (<span class="keyword">const</span> isbn_mismatch&amp; e)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="string">": left isbn("</span> &lt;&lt; e.left</span><br><span class="line">			&lt;&lt; <span class="string">") right isbn("</span> &lt;&lt; e.right &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="命名空间"><a class="markdownIt-Anchor" href="#命名空间"></a> 命名空间</h4>
<p><strong>命名空间定义</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cplusplus_primer &#123;</span><br><span class="line">	<span class="keyword">class</span> Hello &#123;&#125;;</span><br><span class="line">	Hello <span class="keyword">operator</span>+(<span class="keyword">const</span> Hello&amp;, <span class="keyword">const</span> Hello&amp;);</span><br><span class="line">	<span class="keyword">class</span> World &#123;&#125;;</span><br><span class="line">&#125;	<span class="comment">// 命名空间作用域后无需分号。</span></span><br></pre></td></tr></table></figure>
<p>每个命名空间都是一个作用域。内部直接访问，外部要用::。<br>
<code>cplusplus_primer::World w = cpluspluc_primer::W(&quot;hello&quot;);</code><br>
命名空间可以是不连续的。定义多个类型不相关的命名空间应该使用单独的文件分别表示每个类型。<br>
注意我们不把#include放在命名空间内部，如果这么做了，隐含的意思是把头文件中所有的名字定义成该命名空间的成员。<br>
模板特例化必须定义在原始模板所属的命名空间中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们必须将模板特例化声明成std的成员</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">	<span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> hash&lt;Sales_data&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在std中添加了模板特例化的声明后，就可以在命名空间std的外部定义它了</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> hash&lt;Sales_data&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> Sales_data&amp; s) <span class="keyword">const</span>;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(s.bookNo) ^</span><br><span class="line">			hash&lt;<span class="keyword">unsigned</span>&gt;()(s.units_sold) ^</span><br><span class="line">			hash&lt;<span class="keyword">double</span>&gt;()(s.revenue);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>全局命名空间中的成员可以这样调用<code>::member_name</code>。<br>
命名空间可以嵌套。<code>A::B::member_name</code>。<br>
C++11添加了一种内联命名空间，可以直接被外层命名空间使用。定义内联命名空间的方式是在关键字namespace前添加关键字inline，在命名空间第一次定义的地方必须写上。<br>
当应用程序的代码在第一次发布和另一次发布之间发生了改变时，常常会用到内联命名空间。比如早期版本都不内联，当前版本都内联，这样默认就用当前版本的。<br>
未命名命名空间是指关键字namespace后紧跟花括号括起来的一系列声明语句。未命名命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，直到程序结束才销毁。和其他命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件。应当用未命名的命名空间取代文件中的静态声明。</p>
<p><strong>使用命名空间成员</strong><br>
命名空间别名用来为命名空间名字设定一个短一些的同义词。一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字等价。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Qlib = cplusplus_primer::QueryLib;</span><br><span class="line">Qlib::Query q;</span><br></pre></td></tr></table></figure>
<p>using声明如<code>using std::vector;</code>一次只引入命名空间的一个成员。可以出现在全局作用域、局部作用域、命名空间作用域以及类的作用域中。只是简单地令名字在局部作用域内有效。<br>
using指示如<code>using namespace std;</code>使得某个特定命名空间中所有的名字都可见。可以出现在全局作用域、局部作用域和命名空间作用域中，但是不能出现在类的作用域中。令整个命名空间的所有内容变得有效。</p>
<p>如果我们提供了一个对std等命名空间的using指示而未做任何特殊控制的话，将重新引入由于使用了多个库而造成的名字冲突问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> blip &#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">16</span>, j = <span class="number">15</span>, k = <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;	<span class="comment">// 正确：blip的j隐藏在命名空间中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// using指示，blip中的名字被“添加”到全局作用域中</span></span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> blip;	<span class="comment">// 如果使用了j，则将在::j和blip::j之间产生冲突</span></span><br><span class="line">	++i;	<span class="comment">// 将blip::i设定为17</span></span><br><span class="line">	++j;	<span class="comment">// 二义性错误：是全局的j还是blip::j？</span></span><br><span class="line">	++::j;	<span class="comment">// 正确：将全局的j设定为1</span></span><br><span class="line">	++blip::j;	<span class="comment">// 正确：将blip::j设定为16</span></span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">97</span>;	<span class="comment">// 当前局部的k隐藏了blip::k</span></span><br><span class="line">	++k;	<span class="comment">// 将当前局部的k设定为98</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名空间本身的实现文件中可以使用using指示。</p>
<p><strong>类、命名空间与作用域</strong><br>
名字查找还是从内到外。<br>
当我们给函数传递一个类类型的对象/引用/指针时，除了在常规的作用域查找外还会查找实参类所属的命名空间。<br>
std::move和std::forward最好带上限定语，因为很容易冲突，带上可以确保我们用的是标准库的版本。<br>
友元声明与实参相关的查找有个诡异的现象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">	<span class="keyword">class</span> C &#123;</span><br><span class="line">		<span class="comment">// 两个友元，在友元声明之外没有其他的声明</span></span><br><span class="line">		<span class="comment">// 这些函数隐式地成为命名空间A的成员</span></span><br><span class="line">		<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;	<span class="comment">// 除非另有声明，否则不会被找到</span></span><br><span class="line">		<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;	<span class="comment">// 根据实参相关的查找规则可以被找到</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	A::C cobj;</span><br><span class="line">	f(cobj);	<span class="comment">// 正确：通过在A::C中的友元声明找到A::f</span></span><br><span class="line">	f2();		<span class="comment">// 错误：A::f2没有被声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重载与命名空间</strong><br>
using声明语句声明的是一个名字，而非一个特定的函数。<code>using NS::print;</code>。符合该名字的所有版本都被引入到当前作用域中。一个using声明引入的函数将重载该声明语句所属作用域中已有的其他同名函数。<br>
using指示将命名空间的成员提升到外层作用域中，如果命名空间的某个函数与该命名空间所属作用域的函数同名，则命名空间的函数将被添加到重载集合中。与using声明不同的是，对于using指示来说，引入一个与已有函数形参列表完全相同的函数并不会产生错误，此时只要在调用时明确是命名空间中的函数版本还是当前作用域的版本即可。</p>
<h4 id="多重继承与虚继承"><a class="markdownIt-Anchor" href="#多重继承与虚继承"></a> 多重继承与虚继承</h4>
<p>多重继承是指从多个直接基类中产生派生类的能力。</p>
<p><strong>多重继承</strong><br>
多重继承的派生类从每个基类中继承状态。派生类构造函数初始化所有基类。<br>
最好还是每个类为自己定义构造函数吧。</p>
<p><strong>类型转换与多个基类</strong><br>
小心这种二义性错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Bear&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Endangered&amp;)</span></span>;</span><br><span class="line"><span class="function">Panda <span class="title">ying_yang</span><span class="params">(<span class="string">"yingyang"</span>)</span></span>;</span><br><span class="line">print(ying_yang);	<span class="comment">// 二义性错误</span></span><br></pre></td></tr></table></figure>
<p><strong>多重继承下的类作用域</strong><br>
当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。<br>
要想避免潜在的二义性，最好的办法是在派生类中为该函数定义一个新版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> Panda::max_weight() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::max(ZooAnimal::max_weight(), Endangered::max_weight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>虚继承</strong><br>
如果派生类通过它的几个直接基类分别继承了同一个间接基类，需要使用虚继承，这样不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。<br>
虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。所以不太直观。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键字public和virtual顺序随意</span></span><br><span class="line"><span class="keyword">class</span> Raccoon : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> Bear : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> Panda : <span class="keyword">public</span> Bear, <span class="keyword">public</span> Raccoon, <span class="keyword">public</span> Endangered</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构造函数与虚继承</strong><br>
在虚派生中，虚基类是由最低层的派生类初始化的。<br>
也就是说继承体系上此类后的的每个类在初始化的时候都要写对虚基类的初始化，编译器自会选择最低层的那个。<br>
虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。</p>
<h3 id="特殊工具与技术"><a class="markdownIt-Anchor" href="#特殊工具与技术"></a> 特殊工具与技术</h3>
<h4 id="控制内存分配"><a class="markdownIt-Anchor" href="#控制内存分配"></a> 控制内存分配</h4>
<p><strong>重载new和delete</strong><br>
使用new表达式时，实际执行了三步操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new表达式</span></span><br><span class="line"><span class="built_in">string</span>* sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"a value"</span>);	<span class="comment">// 分配并初始化一个string对象</span></span><br><span class="line"><span class="built_in">string</span>* arr = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];	<span class="comment">// 分配10个默认初始化的string对象</span></span><br></pre></td></tr></table></figure>
<ol>
<li>new表达式调用一个名为<code>operator new</code>(或者<code>operator new[]</code>)的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象(或者对象的数组)。</li>
<li>编译器运行相应的构造函数以构造这些对象，并为其传入初始值。</li>
<li>对象被分配了空间并构造完成，返回一个指向该对象的指针。</li>
</ol>
<p>使用delete表达式时，实际执行了两步操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delete表达式</span></span><br><span class="line"><span class="keyword">delete</span> sp;	<span class="comment">// 销毁*sp，然后释放sp指向的内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;	<span class="comment">// 销毁数组中的元素，然后释放对应的内存空间</span></span><br></pre></td></tr></table></figure>
<ol>
<li>对sp所指的对象或者arr所指的数组中的元素执行对应的析构函数。</li>
<li>编译器调用名为<code>operator delete</code>(或者<code>operator delete[]</code>)的标准库函数释放内存空间。</li>
</ol>
<p>如果应用程序希望控制内存分配的过程，则它们需要定义自己的operator new函数和operator delete函数。<br>
当自定义了全局的operator new函数和operator delete函数后，我们就担负起了控制动态内存分配的职责。这两个函数必须是正确的：因为它们是程序整个处理过程中至关重要的一部分。</p>
<p>可以定义在全局作用域中或定义为成员函数。当编译器发现一条new表达式或delete表达式后，将在程序中查找可供调用的operator函数。如果被分配(释放)的对象是类类型，则编译器首先在类及其基类的作用域中查找。此时如果该类含有operator new成员或operator delete成员，则相应的表达式将调用这些成员。否则，编译器在全局作用域查找匹配的函数。此时如果编译器找到了用户自定义的版本，则使用该版本执行new表达式或delete表达式；如果没找到，则使用标准库定义的版本。<br>
可以用作用域运算符如<code>::new</code>只在全局作用域中查找匹配的operator new函数。</p>
<p>标准库定义了operator new函数和operator delete函数的8个重载版本。其中前4个版本可能抛出bad_alloc异常，后4个版本不会抛出异常：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些版本可能抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_t)</span></span>;	<span class="comment">// 分配一个对象</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>);	<span class="comment">// 分配一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span> <span class="keyword">noexcept</span></span>;	<span class="comment">// 释放一个对象</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*) <span class="keyword">noexcept</span>;	<span class="comment">// 释放一个数组</span></span><br><span class="line"><span class="comment">// 这些版本承诺不会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_t, nothrow_t&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>, <span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, nothrow_t&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*, <span class="keyword">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>
<p>自定义的版本必须位于全局作用域或者类作用域中。当定义成类的成员时，它们是隐式静态的。因为operator new用在对象构造之前而operator delete用在对象销毁之后，所以这两个成员new和delete必须是静态的，而且它们不能操纵类的任何数据成员。<br>
可以在重载中使用定义在C语言<code>&lt;cstdlib&gt;</code>头文件中的<code>malloc</code>和<code>free</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_t size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">void</span> *mem = <span class="built_in">malloc</span>(size))</span><br><span class="line">		<span class="keyword">return</span> mem;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">throw</span> bad_alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *mem)</span> <span class="keyword">noexcept</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>定位new表达式</strong><br>
对于operator new分配的内存空间来说，应该使用new的定位new(placement new)形式构造对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new (place_address) type</span><br><span class="line">new (place_address) type (initializers)</span><br><span class="line">new (place_address) type [size]</span><br><span class="line">new (place_address) type [size] &#123;braced initializer list&#125;</span><br></pre></td></tr></table></figure>
<p>其中place_address必须是一个指针，同时在initializers中提供一个(可能为空的)以逗号分隔的初始值列表，该初始值列表将用于构造新分配的对象。<br>
当仅通过一个地址值调用时，定位new，使用<code>operator new(size_t, void*)</code>这个函数简单地返回指针实参，然后由new表达式负责在指定的地址初始化对象以完成整个工作。事实上，定位new允许我们在一个特定的、预先分配的内存地址上构造对象。<br>
当只传入一个指针类型的实参时，定位new表达式构造对象但是不分配内存。</p>
<p>很多时候定位new与allocator的construct成员非常相似，但它们之间有一个重要的区别。我们传给construct的指针必须指向同一个allocator对象分配的空间，但是传给定位new的指针无须指向operator new分配的内存。传给定位new表达式的指针甚至不需要指向动态内存。</p>
<p>可以显式调用析构函数。调用析构函数会销毁对象，但是不会释放内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"a value"</span>);	<span class="comment">// 分配并初始化一个string对象</span></span><br><span class="line">sp-&gt;~<span class="built_in">string</span>();</span><br></pre></td></tr></table></figure>
<h4 id="运行时类型识别"><a class="markdownIt-Anchor" href="#运行时类型识别"></a> 运行时类型识别</h4>
<p>运行时类型识别(run-time type identification, RTTI)的功能由两个运算符实现：</p>
<ul>
<li><code>typeid</code>运算符，用于返回表达式的类型。</li>
<li><code>dynamic_cast</code>运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用。</li>
</ul>
<p>这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数。<br>
使用RTTI必须要加倍小心。在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。</p>
<p><strong>dynamic_cast运算符</strong><br>
dynamic_cast的使用形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic_cast</span>&lt;type*&gt;(e)	<span class="comment">// e必须是一个有效的指针</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&gt;(e)	<span class="comment">// e必须是一个左值</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e)	<span class="comment">// e不能是左值</span></span><br></pre></td></tr></table></figure>
<p>如果dynamic_cast的转换目标是指针类型并且失败了，则结果为0；如果转换目标是引用类型并且失败了，则将抛出一个bad_cast异常。</p>
<p>我们可以对一个空指针执行dynamic_cast，结果是所需类型的空指针。<br>
在条件部分执行dynamic_cast操作可以确保类型转换和结果检查在同一条表达式中完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Derived* dp = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(bp))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 使用dp指向的Derived对象</span></span><br><span class="line">&#125;<span class="keyword">else</span>	<span class="comment">// bp指向一个Base对象</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 使用bp指向的Base对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于引用类型的dynamic_cast，失败时抛出名为<code>std::bad_cast</code>的异常，定义在标准库头文件<code>&lt;typeinfo&gt;</code>中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Base&amp; b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> Derived&amp; d = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Derived&amp;&gt;(b);</span><br><span class="line">		<span class="comment">// 使用b引用的Derived对象</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (bad_cast) &#123;</span><br><span class="line">		<span class="comment">// 处理类型转换失败的情况</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>typeid运算符</strong><br>
<code>typeid(e)</code>，其中e可以是任意表达式或类型的名字。typeid操作的结果是一个常量对象的引用，该对象的类型是标准库类型type_info或者type_info的公有派生类型。type_info类定义在typeinfo头文件中。<br>
通常使用typeid比较两条表达式的类型是否相同，或者比较一条表达式的类型是否与指定类型相同。<br>
当typeid作用于指针(而非指针所指的对象)时，返回的结果是该指针的静态编译时类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Derived* dp = <span class="keyword">new</span> Derived;</span><br><span class="line">Base* bp = dp;	<span class="comment">// 两个指针都指向Derived对象</span></span><br><span class="line"><span class="comment">// 在运行时比较两个对象的类型</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeid</span>(*bp) == <span class="keyword">typeid</span>(*dp))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// bp和dp指向同一类型的对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查运行时类型是否是某种指定的类型</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeid</span>(*bp) == <span class="keyword">typeid</span>(Derived))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// bp实际指向Derived对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面的检查永远是失败的：bp的类型是指向Base的指针</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeid</span>(bp) == <span class="keyword">typeid</span>(Derived))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 此处的代码永远不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用RTTI</strong><br>
示例：继承层次中类的相等比较。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">class</span> Base</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Base&amp;, <span class="keyword">const</span> Base&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Base的接口成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">const</span> Base&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="comment">// Base的数据成员和其他用于实现的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Derived : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Derived的其他接口成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">const</span> Base&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="comment">// Derived的数据成员和其他用于实现的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类实现</span></span><br><span class="line"><span class="keyword">bool</span> Base::equal(<span class="keyword">const</span> Base&amp; rhs) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 执行比较Base对象的操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> Derived::equal(<span class="keyword">const</span> Base&amp; rhs) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 我们清楚这两个类型是相等的，所以转换过程不会抛出异常</span></span><br><span class="line">	<span class="keyword">auto</span> r = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Derived&amp;&gt;(rhs);</span><br><span class="line">	<span class="comment">// 执行比较两个Derived对象的操作并返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义整体的相等运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Base&amp; lhs, <span class="keyword">const</span> Base&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 如果typeid不相同，返回false；否则虚调用equal</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">typeid</span>(lhs) == <span class="keyword">typeid</span>(rhs) &amp;&amp; lhs.equal(rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>type_info类</strong><br>
type_info类必须定义在typeinfo头文件中，提供以下操作。</p>
<table>
<thead>
<tr>
<th></th>
<th>type_info的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>t1 == t2</code></td>
<td>如果type_info对象t1和t2表示同一种类型，返回true；否则返回false</td>
</tr>
<tr>
<td><code>t1 != t2</code></td>
<td>如果type_info对象t1和t2表示不同的类型，返回true；否则返回false</td>
</tr>
<tr>
<td><code>t.name()</code></td>
<td>返回一个C风格字符串，表示类型名字的可打印形式。类型名字的生成方式因系统而异</td>
</tr>
<tr>
<td><code>t1.before(t2)</code></td>
<td>返回一个bool值，表示t1是否位于t2之前。before所采用的的顺序关系时依赖于编译器的</td>
</tr>
</tbody>
</table>
<p>type_info类没有默认构造函数，并且它的拷贝和移动构造函数以及赋值运算符都被定义为删除的。创建type_info对象的唯一途径是使用typeid运算符。<br>
name()返回值的唯一要求是，类型不同则返回的字符串必须有区别。</p>
<h4 id="枚举类型"><a class="markdownIt-Anchor" href="#枚举类型"></a> 枚举类型</h4>
<p>枚举属于字面值常量类型。枚举值不一定唯一。<br>
C++包含两种枚举：限定作用域的和不限定作用域的。</p>
<ul>
<li>限定作用域的枚举类型(scoped enumeration)。C++11后。<br>
枚举成员的名字遵循常规的作用域规则，并且在枚举类型的作用域外是不可访问的。<br>
<code>enum class EnumName {Enum1, Enum2, Enum3};</code></li>
<li>不限定作用域的枚举类型(unscoped enumeration)。<br>
枚举成员的作用域与枚举类型本身的作用域相同。<br>
<code>enum EnumName {Enum1, Enum2, Enum3};</code><br>
可以没有名字。<br>
<code>enum {Enum1 = 5, Enum2 = 1, Enum3 = 1};</code></li>
</ul>
<p>要想初始化enum对象或者为enum对象赋值，必须使用该类型的一个枚举成员或者该类型的另一个对象。<code>EnumName en = EnumName::Enum2;</code><br>
不限定作用域的枚举类型的对象或枚举成员可以自动地转换为整形，限定作用域的枚举类型不可以。</p>
<p>C++11中可以指定enum是某种整数类型。指定类型可以确保在一种实现环境中编译通过的程序所生成的代码在其他实现环境中生成的代码一致。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> intValues : <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line">&#123;</span><br><span class="line">	charTyp = <span class="number">255</span>,</span><br><span class="line">	shorTyp = <span class="number">65535</span>,</span><br><span class="line">	intTyp = <span class="number">65535</span>,</span><br><span class="line">	longTyp = <span class="number">4294967295U</span>L,</span><br><span class="line">	long_longTyp = <span class="number">18446744073709551615U</span>LL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>C++11中可以提前声明enum。enum的前置声明必须指定其成员大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> intValues : <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;	<span class="comment">// 不限定作用域的，必须指定成员类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> open_modes;	<span class="comment">// 限定作用域的枚举类型可以使用默认成员类型int</span></span><br></pre></td></tr></table></figure>
<h4 id="类成员指针"><a class="markdownIt-Anchor" href="#类成员指针"></a> 类成员指针</h4>
<p>成员指针是指可以指向类的非静态成员的指针。一般情况下，指针指向一个对象，但是成员指针指示的是类的成员，而非类的对象。<br>
成员指针的类型囊括了类的类型以及成员的类型。当初始化一个这样的指针时，我们令其指向类的某个成员，但是不指定该成员所属的对象；直到使用成员指针时，才提供成员所属的对象。<br>
示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Screen</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">get_cursor</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> contents[cursor];&#125;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">(pos ht, pos wd)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">	pos cursor;</span><br><span class="line">	pos height, width;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>数据成员指针</strong><br>
需要指明所属的类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pdata可以指向一个常量(非常量)Screen对象的string成员</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> Screen::*pdata;</span><br><span class="line">pdata = &amp;Screen::contents;</span><br></pre></td></tr></table></figure>
<p>与成员访问运算符<code>.</code>和<code>-&gt;</code>类似，也有两种成员指针访问运算符：<code>.*</code>和<code>-&gt;*</code>，这两个运算符使得我们可以解引用指针并获得该对象的成员：<br>
从概念上来说，这些运算符执行两步操作：它们首先解引用成员指针以得到所需的成员；然后像成员访问运算符一样，通过对象<code>.*</code>或指针<code>-&gt;*</code>获取成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Screen myScreen, *pScreen = &amp;myScreen;</span><br><span class="line"><span class="comment">// .*解引用pdata以获得myScreen对象的contents成员</span></span><br><span class="line"><span class="keyword">auto</span> s = myScreen.*pdata;</span><br><span class="line"><span class="comment">// -&gt;*解引用pdata以获得pScreen所指对象的contents成员</span></span><br><span class="line">s = pScreen-&gt;*pdata;</span><br></pre></td></tr></table></figure>
<p>为Screen类添加一个静态成员，令其返回指向contents成员的指针。从右向左阅读函数的返回类型，可知data返回的是一个指向Screen类的const string成员的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Screen</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// data是一个静态成员，返回一个成员指针</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> Screen::*data()</span><br><span class="line">	&#123;<span class="keyword">return</span> &amp;Screen::contents;&#125;</span><br><span class="line">	<span class="comment">// other...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>pdata指向Screen类的成员而非实际数据。要想使用pdata，必须把它绑定到Screen类型的对象上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得myScreen对象的contents成员</span></span><br><span class="line"><span class="keyword">auto</span> s = myScreen.*pdata;</span><br></pre></td></tr></table></figure>
<p><strong>成员函数指针</strong><br>
指向类的成员函数的指针。类似于任何其他函数指针，指向成员函数的指针也需要指定目标函数的返回类型和形参列表。如果成员函数是const成员或者引用成员，则必须将const限定符或引用限定符包含进来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pmf是一个指针，它可以指向Screen的某个常量成员函数</span></span><br><span class="line"><span class="comment">// 前提是该函数不接受任何实参，并且返回一个char</span></span><br><span class="line"><span class="keyword">auto</span> pmf = &amp;Screen::get_cursor;</span><br><span class="line"><span class="comment">// 声明一个指针，令其指向含有两个形参的get</span></span><br><span class="line"><span class="keyword">char</span> (Screen::*pmf2)(Screen::pos, Screen::pos) <span class="keyword">const</span>;</span><br><span class="line">pmf2 = &amp;Screen::get;</span><br></pre></td></tr></table></figure>
<p>和普通函数指针不同，成员函数和指向该成员的指针之间不存在自动转换规则。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pmf指向一个Screen成员，该成员不接受任何实参且返回类型是char</span></span><br><span class="line">pmf = &amp;Screen::get;	<span class="comment">// 必须显式地使用取地址运算符</span></span><br><span class="line">pmf = Screen::get;	<span class="comment">// 错误：在成员函数和指针之间不存在自动转换规则</span></span><br></pre></td></tr></table></figure>
<p>使用<code>.*</code>或者<code>-&gt;*</code>运算符作用于指向成员函数的指针，以调用类的成员函数：<br>
注意括号必不可少。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Screen myScreen, *pScreen = &amp;myScreen;</span><br><span class="line"><span class="comment">// 通过pScreen所指的对象调用pmf所指的函数</span></span><br><span class="line"><span class="keyword">char</span> c1 = (pScreen-&gt;*pmf)();</span><br><span class="line"><span class="comment">// 通过myScreen对象将实参0,0传给含有两个形参的get函数</span></span><br><span class="line"><span class="keyword">char</span> c2 = (myScreen.*pmf2)(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>可以使用类型别名或typedef，易读一些。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Action是一种可以指向Screen成员函数的指针，它接受两个pos实参，返回一个char</span></span><br><span class="line"><span class="keyword">using</span> Action = <span class="keyword">char</span> (Screen::*)(Screen::pos, Screen::pos) <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">// 简化指向get的指针定义</span></span><br><span class="line">Action get = &amp;Screen::get;	<span class="comment">// get指向Screen的get成员</span></span><br></pre></td></tr></table></figure>
<p>也可以将指向成员函数的指针作为某个函数的返回类型或形参类型。指向成员的指针形参也可以拥有默认形参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// action接受一个Screen的引用，和一个指向Screen成员函数的指针</span></span><br><span class="line"><span class="function">Screen&amp; <span class="title">action</span><span class="params">(Screen&amp;, Action = &amp;Screen::get)</span></span>;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Screen myScreen;</span><br><span class="line"><span class="comment">// 等价的调用：</span></span><br><span class="line">action(myScreen);	<span class="comment">// 使用默认实参</span></span><br><span class="line">action(myScreen, get);	<span class="comment">// 使用我们之间定义的变量get</span></span><br><span class="line">action(myScreen, &amp;Screen::get);	<span class="comment">// 显式地传入地址</span></span><br></pre></td></tr></table></figure>
<p>用途：对于普通函数指针和指向成员函数的指针来说，一种常见的用法是将其存入一个函数表当中。如果一个类含有几个相同类型的成员，则这样一张表可以帮助我们从这些成员中选择一个。<br>
示例：Screen类含有几个负责移动光标的成员函数。参数与返回值都相同。此时可以再定义一个move函数，使其可以调用其中任意一个函数并执行对应的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Screen</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Screen&amp; <span class="title">home</span><span class="params">()</span></span>;	<span class="comment">// 光标移动函数</span></span><br><span class="line">	<span class="function">Screen&amp; <span class="title">forward</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Screen&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Screen&amp; <span class="title">up</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">Screen&amp; <span class="title">down</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// Action是一个指针，可以用任意一个光标移动函数对其赋值</span></span><br><span class="line">	<span class="keyword">using</span> Action = Screen&amp; (Screen::*)();</span><br><span class="line">	<span class="comment">// 指定具体要移动的方向</span></span><br><span class="line">	<span class="keyword">enum</span> Directions &#123;HOME, FORWARD, BACK, UP, DOWN&#125;;</span><br><span class="line">	<span class="function">Screen&amp; <span class="title">move</span><span class="params">(Directions)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> Action Menu[];	<span class="comment">// 函数表</span></span><br><span class="line">&#125;;</span><br><span class="line">Screen&amp; Screen::move(Directions cm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 运行this对象中索引值为cm的元素</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span>-&gt;*Menu[cm])();	<span class="comment">// Menu[cm]指向一个成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用时</span></span><br><span class="line">Screen myScreen;</span><br><span class="line">myScreen.move(Screen::HOME);	<span class="comment">// 调用myScreen.home</span></span><br><span class="line">myScreen.move(Screen::DOWN);	<span class="comment">// 调用myScreen.down</span></span><br><span class="line"><span class="comment">// 定义并初始化函数表</span></span><br><span class="line">Screen::Action Screen::Menu[] = </span><br><span class="line">			&#123;</span><br><span class="line">				&amp;Screen::home,</span><br><span class="line">				&amp;Screen::forward,</span><br><span class="line">				&amp;Screen::back,</span><br><span class="line">				&amp;Screen::up,</span><br><span class="line">				&amp;Screen::down</span><br><span class="line">			&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>将成员函数用作可调用对象</strong><br>
要想通过一个指向成员函数的指针进行函数调用，必须首先利用<code>.*</code>运算符或<code>-&gt;*</code>运算符将该指针绑定到特定的对象上。因此与普通的函数指针不同，成员指针不是一个可调用对象，这样的指针不支持函数调用运算符。</p>
<p>从指向成员函数的指针获取可调用对象的一种方法是使用标准库<code>function</code>。必须提供成员的调用形式。<br>
例如：这是告诉function，string类里的empty是一个接受string参数并返回bool值的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">bool</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp;)&gt; fcn = &amp;<span class="built_in">string</span>::empty;</span><br><span class="line">find_if(svec.begin(), svec.end(), fcn);</span><br></pre></td></tr></table></figure>
<p>从指向成员函数的指针获取可调用对象的第二种方法是使用标准库功能<code>mem_fn</code>来让编译器负责推断成员的类型。也定义在<code>&lt;functional&gt;</code>头文件中，和function不同的是，mem_fn可以根据成员指针的类型推断可调用对象的类型，无需用户显式指定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_if(svec.begin(), svec.end(), mem_fn(&amp;<span class="built_in">string</span>::empty));</span><br></pre></td></tr></table></figure>
<p>mem_fn生成的可调用对象可以通过对象调用，也可以通过指针调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = mem_fn(&amp;<span class="built_in">string</span>::empty);	<span class="comment">// f接受一个string或者一个string*</span></span><br><span class="line">f(*svec.begin());	<span class="comment">// 正确：传入一个string对象，f使用.*调用empty</span></span><br><span class="line">f(&amp;svec[<span class="number">0</span>]);	<span class="comment">// 正确：传入一个string的指针，f使用-&gt;*调用empty</span></span><br></pre></td></tr></table></figure>
<p>也可使用<code>bind</code>生成一个可调用对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择范围中的每个string，并将其bind到empty的第一个隐式实参上</span></span><br><span class="line"><span class="keyword">auto</span> it = find_if(svec.begin(), svec.end(), bind(&amp;<span class="built_in">string</span>::empty, _1));</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">auto</span> f = bind(&amp;<span class="built_in">string</span>::empty, _1);</span><br><span class="line">f(*svec.begin());	<span class="comment">// 正确：实参是一个string, f使用*调用empty</span></span><br><span class="line">f(&amp;svec[<span class="number">0</span>]);	<span class="comment">// 正确：实参是一个string的指针，f使用-&gt;*调用empty</span></span><br></pre></td></tr></table></figure>
<h4 id="嵌套类"><a class="markdownIt-Anchor" href="#嵌套类"></a> 嵌套类</h4>
<p>nested class是独立的，与外层类基本没什么关系。特别是，外层类的对象和嵌套类的对象是相互独立的。在嵌套类的对象中不包含任何外层类定义的成员；类似的，在外层类的对象中也不包含任何嵌套类定义的成员。<br>
嵌套类的名字在外层作用域中是可见的，在外层类作用域之外不可见。<br>
外层类对嵌套类的成员没有特殊的访问权限，同样，嵌套类对外层类的成员也没有特殊的访问权限。<br>
嵌套类在其外层类中定义了一个类型成员。和其他成员类似，该类型的访问权限由外层类决定。位于外层类public部分的嵌套类实际上定义了一种可以随处访问的类型；位于外层类protected部分的嵌套类定义的类型只能被外层类及其友元和派生类访问；位于外层类private部分的嵌套类定义的类型只能被外层类的成员和友元访问。<br>
在嵌套类在其外层类之外完成真正的定义之前，它都是一个不完全类型。<br>
返回类型不在类的作用域中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> TextQuery</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">class</span> QueryResult;	<span class="comment">// 嵌套类稍后定义</span></span><br><span class="line">	<span class="comment">// other</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// QueryResult是TextQuery的成员，下面的代码负责定义QueryResult</span></span><br><span class="line"><span class="keyword">class</span> TextQuery::QueryResult</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 位于类的作用域内，因此我们不必对QueryResult形参进行限定</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="built_in">std</span>::<span class="function">ostream&amp; <span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> QueryResult&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 无需定义QueryResult::line_no</span></span><br><span class="line">	<span class="comment">// 嵌套类可以直接使用外层类的成员，无需对该成员的名字进行限定</span></span><br><span class="line">	QueryResult(<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;line_no&gt;&gt;, <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt;);</span><br><span class="line">	<span class="comment">// Other</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// QueryResult类嵌套在TextQuery类中</span></span><br><span class="line"><span class="comment">// 下面的代码为QueryResult类定义名为QueryResult的成员</span></span><br><span class="line">TextQuery::QueryResult::QueryResult(<span class="built_in">string</span> s, <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt; p, <span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; f)</span><br><span class="line">	: sought(s), lines(p), file(f)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">// 下面的代码为QueryResult定义一个静态成员</span></span><br><span class="line"><span class="keyword">int</span> TextQuery::QueryResult::static_mem = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// 返回类型不在类的作用域中，因此必须指明QueryResult是一个嵌套类。函数体内部就可以直接访问QueryResult</span></span><br><span class="line">TextQuery::QueryResult TextQuery::query(<span class="keyword">const</span> <span class="built_in">string</span>&amp; sought) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 如果我们没有找到sought，则返回set的指针</span></span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">shared_ptr</span>&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt; nodata(<span class="keyword">new</span> <span class="built_in">set</span>&lt;line_no&gt;);</span><br><span class="line">	<span class="comment">// 使用find而非下标以避免向wm中添加单词</span></span><br><span class="line">	<span class="keyword">auto</span> loc = wm.find(sought);</span><br><span class="line">	<span class="keyword">if</span> (loc == wm.end())</span><br><span class="line">		<span class="keyword">return</span> QueryResult(sought, nodata, file);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> QueryResult(sought, loc-&gt;second, file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="union一种节省空间的类"><a class="markdownIt-Anchor" href="#union一种节省空间的类"></a> union：一种节省空间的类</h4>
<p>联合union是一种特殊的类。可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当我们给union的某个成员赋值之后，该union的其他成员就变成未定义的状态了。分配给一个union对象的存储空间至少要能容纳它的最大的数据成员。和其它类一样，一个union定义了一个新类型。<br>
union不能含有引用类型的成员。在C++11中，含有构造函数或析构函数的类类型也可以作为union的成员类型。union可以为其成员指定public、protected、private等保护标记。默认情况下，union的成员都是公有的。<br>
union可以定义包括构造函数和析构函数在内的成员函数。但是由于union既不能继承自其他类，也不能作为基类使用，所以在union中不能含有虚函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token类型的对象只有一个成员，该成员的类型可能是下列类型中的任意一种</span></span><br><span class="line"><span class="keyword">union</span> Token</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 默认情况下成员是公有的</span></span><br><span class="line">	<span class="keyword">char</span> cval;</span><br><span class="line">	<span class="keyword">int</span> ival;</span><br><span class="line">	<span class="keyword">double</span> dval;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为union的一个数据成员赋值会令其他数据成员变成未定义的状态，因此，使用union时，必须清楚地知道当前存储在union中的值到底是什么类型。如果用错了，不是吓唬你，可能会崩溃的！</p>
<p>匿名union一旦定义，编译器就自动为该union创建一个未命名的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;	<span class="comment">// 匿名union</span></span><br><span class="line">	<span class="keyword">char</span> cval;</span><br><span class="line">	<span class="keyword">int</span> ival;</span><br><span class="line">	<span class="keyword">double</span> dval;</span><br><span class="line">&#125;;	<span class="comment">// 定义一个未命名的对象，我们可以直接访问它的成员</span></span><br><span class="line">cval = <span class="string">'c'</span>;	<span class="comment">// 为刚刚定义的未命名的匿名union对象赋一个新值</span></span><br><span class="line">ival = <span class="number">42</span>;	<span class="comment">// 该对象当前保存的值是42</span></span><br></pre></td></tr></table></figure>
<p>匿名union不能包含受保护的成员或私有成员，也不能定义成员函数。</p>
<p>可以使用类管理union成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Token</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 因为union含有一个string成员，所以Token必须定义拷贝控制成员</span></span><br><span class="line">	Token() : tok(INT), ival&#123;<span class="number">0</span>&#125; &#123;&#125;</span><br><span class="line">	Token(<span class="keyword">const</span> Token&amp; t) : tok(t.tok) &#123;copyUnion(t);&#125;</span><br><span class="line">	Token &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Token&amp;);</span><br><span class="line">	<span class="comment">// 如果union含有一个string成员，则我们必须销毁它</span></span><br><span class="line">	~Token() &#123;<span class="keyword">if</span> (tok == STR) sval.~<span class="built_in">string</span>();&#125;</span><br><span class="line">	<span class="comment">// 下面的赋值运算符负责设置union的不同成员</span></span><br><span class="line">	Token &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;);</span><br><span class="line">	Token &amp;<span class="keyword">operator</span>=(<span class="keyword">char</span>);</span><br><span class="line">	Token &amp;<span class="keyword">operator</span>=(<span class="keyword">int</span>);</span><br><span class="line">	Token &amp;<span class="keyword">operator</span>=(<span class="keyword">double</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">enum</span> &#123;INT, CHAR, DBL, STR&#125; tok;	<span class="comment">// 判别式</span></span><br><span class="line">	<span class="keyword">union</span> &#123;	<span class="comment">// 匿名union</span></span><br><span class="line">		<span class="keyword">char</span> cval;</span><br><span class="line">		<span class="keyword">int</span> ival;</span><br><span class="line">		<span class="keyword">double</span> dval;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> sval;</span><br><span class="line">	&#125;;	<span class="comment">// 每个Token对象含有一个该未命名union类型的未命名成员</span></span><br><span class="line">	<span class="comment">// 检查判别式，然后酌情拷贝union成员</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">copyUnion</span><span class="params">(<span class="keyword">const</span> Token&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果union的当前值是string，则需先调用string的析构函数销毁这个string，然后再为union赋新值</span></span><br><span class="line">Token &amp;Token::<span class="keyword">operator</span>=(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (tok == STR) sval.~<span class="built_in">string</span>();	<span class="comment">// 如果当前存储的是string，释放它</span></span><br><span class="line">	ival = i;	<span class="comment">// 为成员赋值</span></span><br><span class="line">	tok = INT;	<span class="comment">// 更新判别式</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果union存储的string，则可以用普通的string赋值运算符直接为其赋值。</span></span><br><span class="line"><span class="comment">// 如果union当前存储的不是string，则我们找不到一个已存在的string对象供我们调用赋值运算符。</span></span><br><span class="line"><span class="comment">// 必须先利用定位new表达式在内存中为sval构造一个string，然后将该string初始化为string形参的副本，最后更新判别式并返回结果。</span></span><br><span class="line">Token &amp;Token::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (tok == STR)	<span class="comment">// 如果当前存储的是string，可以直接赋值</span></span><br><span class="line">		sval = s;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">new</span>(&amp;sval) <span class="built_in">string</span>(s);	<span class="comment">// 否则需要先构造一个string</span></span><br><span class="line">	tok = STR;	<span class="comment">// 更新判别式</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// copyUnion假设如果它的形参存储了string，则它一定会构造自己的string</span></span><br><span class="line"><span class="keyword">void</span> Token::copyUnion(<span class="keyword">const</span> Token&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (t.tok)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> Token::INT: ival = t.ival; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> Token::CHAR: cval = t.cval; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> Token::DBL; dval = t.dval; <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// 要想拷贝一个string可以使用定位new表达式构造它</span></span><br><span class="line">		<span class="keyword">case</span> Token::STR: <span class="keyword">new</span>(&amp;sval) <span class="built_in">string</span>(t.sval); <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值运算符必须处理string成员的三种可能情况：</span></span><br><span class="line"><span class="comment">// 左侧运算对象和右侧运算对象都是string、两个运算对象都不是string、只有一个运算对象是string</span></span><br><span class="line">Token&amp; Token::<span class="keyword">operator</span>=(<span class="keyword">const</span> Token&amp; t)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 如果此对象的值是string而t的值不是，则我们必须释放原来的string</span></span><br><span class="line">	<span class="keyword">if</span> (tok == STR &amp;&amp; t.tok != STR) sval.~<span class="built_in">string</span>();</span><br><span class="line">	<span class="keyword">if</span> (tok == STR &amp;&amp; t.tok == STR)</span><br><span class="line">		sval = t.sval;	<span class="comment">// 无需构造一个新string</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		copyUnion(t);	<span class="comment">// 如果t.tok是STR，则需要构造一个string</span></span><br><span class="line">	tok = t.tok;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="局部类"><a class="markdownIt-Anchor" href="#局部类"></a> 局部类</h4>
<p>类可以定义在某个函数的内部，成为局部类local class。局部类定义的类型只在定义它的作用域内可见。<br>
局部类的所有成员(包括函数在内)都必须完整定义在类的内部。因此，局部类的作用与嵌套类相比相差很远。<br>
局部类中不允许声明静态数据成员，因为根本没法定义。<br>
局部类对其外层作用域中名字的访问权限受到很多限制：局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员。如果局部类定义在某个函数内部，则该函数的普通局部变量不能被该局部类使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, val;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> val)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> si;</span><br><span class="line">	<span class="keyword">enum</span> Loc &#123;a = <span class="number">1024</span>, b&#125;;</span><br><span class="line">	<span class="comment">// Bar是foo的局部类</span></span><br><span class="line">	<span class="keyword">struct</span> Bar</span><br><span class="line">	&#123;</span><br><span class="line">		Loc locVal;	<span class="comment">// 正确：使用一个局部类型名</span></span><br><span class="line">		<span class="keyword">int</span> barVal;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">(Loc l = a)</span>	<span class="comment">// 正确：默认实参是Loc::a</span></span><br><span class="line">		</span>&#123;</span><br><span class="line">			barVal = val;	<span class="comment">// 错误：val是foo的局部变量</span></span><br><span class="line">			barVal = ::val;	<span class="comment">// 正确：使用一个全局对象</span></span><br><span class="line">			barVal = si;	<span class="comment">// 正确：使用一个静态局部对象</span></span><br><span class="line">			locVal = b;	<span class="comment">// 正确：使用一个枚举成员</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="固有的不可移植的特性"><a class="markdownIt-Anchor" href="#固有的不可移植的特性"></a> 固有的不可移植的特性</h4>
<p>为了支持低层编程，C++定义了一些固有的不可移植nonportable的特性。所谓不可移植的特性是指因机器而异的特性，当我们将含有不可移植特性的程序从一台机器转移到另一台机器上时，通常需要重新编写该程序。</p>
<p><strong>位域</strong><br>
类可以将其(非静态)数据成员定义成位域(bit-field)，在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。<br>
位域在内存中的布局是机器相关的。<br>
位域的类型必须是整型或枚举类型。<br>
通常情况下最好将位域设为无符号类型，存储在带符号类型中的位域的行为将因具体实现而定。<br>
位域的声明形式是在成员名字之后紧跟一个冒号以及一个常量表达式，该表达式用于指定成员所占的二进制位数。<br>
取地址运算符<code>&amp;</code>不能作用于位域，因此任何指针都无法指向类的位域。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> Bit;</span><br><span class="line"><span class="keyword">class</span> File</span><br><span class="line">&#123;</span><br><span class="line">	Bit mode: <span class="number">2</span>;	<span class="comment">// mode占2位</span></span><br><span class="line">	Bit modified: <span class="number">1</span>;	<span class="comment">// modified占1位</span></span><br><span class="line">	Bit prot_owner: <span class="number">3</span>;	<span class="comment">// prot_owner占3位</span></span><br><span class="line">	Bit prot_group: <span class="number">3</span>;	<span class="comment">// prot_group占3位</span></span><br><span class="line">	Bit prot_world: <span class="number">3</span>;	<span class="comment">// prot_world占3位</span></span><br><span class="line">	<span class="comment">// File的操作和数据成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 文件类型以八进制的形式表示</span></span><br><span class="line">	<span class="keyword">enum</span> modes &#123;READ = <span class="number">01</span>, WRITE = <span class="number">02</span>, EXECUTE = <span class="number">03</span>&#125;;</span><br><span class="line">	<span class="function">File&amp; <span class="title">open</span><span class="params">(modes)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isRead</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setWrite</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用位域</span></span><br><span class="line"><span class="keyword">void</span> File::write()</span><br><span class="line">&#123;</span><br><span class="line">	modified = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> File::close()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (modified)</span><br><span class="line">		<span class="comment">// ......保存内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通常使用内置的位运算符操作超过1位的位域</span></span><br><span class="line">File&amp; File::open(File::modes m)</span><br><span class="line">&#123;</span><br><span class="line">	mode |= READ;	<span class="comment">// 按默认方式设置READ</span></span><br><span class="line">	<span class="comment">// 其他处理</span></span><br><span class="line">	<span class="keyword">if</span> (m &amp; WRITE)	<span class="comment">// 如果打开了READ和WRITE</span></span><br><span class="line">	<span class="comment">// 按照读/写方式打开文件</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果一个类定义了位域成员，则它通常也会定义一组内联的成员函数以检验或设置位域的值</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> File::isRead() <span class="keyword">const</span> &#123;<span class="keyword">return</span> mode &amp; READ;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> File::setWrite() &#123;mode |= WRITE;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>volatile限定符</strong><br>
volatile的确切含义与机器有关，只能通过阅读编译器文档来理解。要想让使用了volatile的程序在移植到新机器或新编译器后仍然有效，通常需要对该程序进行某些改变。<br>
直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程控制。例如，程序可能包含一个由系统时钟定时更新的变量。当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为volatile。关键字volatile告诉编译器不应对这样的对象进行优化。<br>
使用方式和const很像。<br>
只有volatile的成员函数才能被volatile的对象调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> display_register;	<span class="comment">// 该int值可能发生改变</span></span><br><span class="line"><span class="keyword">volatile</span> Task* curr_task;	<span class="comment">// curr_task指向一个volatile对象</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> iax[max_size];	<span class="comment">// iax的每个元素都是volatile</span></span><br><span class="line"><span class="keyword">volatile</span> Screen bitmapBug;	<span class="comment">// bitmapBuf的每个成员都是volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> v;	<span class="comment">// v是一个volatile int</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">volatile</span> vip;	<span class="comment">// vip是一个volatile指针，它指向int</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span>* ivp;	<span class="comment">// ivp是一个指针，它指向一个volatile int</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span>* <span class="keyword">volatile</span> vivp;	<span class="comment">// vivp是一个volatile指针，它指向一个volatile int</span></span><br><span class="line"><span class="comment">//---</span></span><br><span class="line"><span class="keyword">int</span> *ip = &amp;v;	<span class="comment">// 错误：必须使用指向volatile的指针</span></span><br><span class="line">ivp = &amp;v;	<span class="comment">// 正确：ivp是一个指向volatile的指针</span></span><br><span class="line">vivp = &amp;v;	<span class="comment">// 正确：vivp是一个指向bolatile的volatile指针</span></span><br></pre></td></tr></table></figure>
<p>合成的拷贝对volatile对象无效，需要自己定义拷贝和赋值操作，不过这其实没什么意义。</p>
<p><strong>链接指示：extern &quot;C&quot;</strong><br>
C<ins>使用链接指示(linkage directive)指出任意非C</ins>函数所用的语言。<br>
要想把C<ins>代码和其他语言(包括C语言)编写的代码放在一起使用，要求我们必须有权访问该语言的编译器，并且这个编译器与当前的C</ins>编译器是兼容的。<br>
如<code>extern &quot;Ada&quot;</code>，<code>extern &quot;FORTRAN&quot;</code>等。</p>
<p>声明一个非C++的函数：<br>
链接指示可以有两种形式：单个的或复合的。链接指示不能出现在类定义或函数定义的内部。同样的链接指示必须在函数的每个声明中都出现。<br>
例子：cstring头文件的某些C函数是如何声明的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能出现在C++头文件&lt;cstring&gt;中的链接指示</span></span><br><span class="line"><span class="comment">// 单语句链接指示</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line"><span class="comment">// 复合语句链接指示</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">char</span>* <span class="title">strcat</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链接指示与头文件：<br>
可以这样一次性建立多个链接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复合语句链接指示</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>	// 操作C风格字符串的C函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指向extern &quot;C&quot;函数的指针：<br>
编写函数所用的语言是函数类型的一部分。因此，对于使用链接指示定义的函数来说，它的每个声明都必须使用相同的链接指示。而且，指向其他语言编写的函数的指针必须与函数本身使用相同的链接指示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pf指向一个C函数，该函数接受一个int返回void</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">void</span> (*pf)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>指向C函数的指针与指向C++函数的指针是不一样的类型。</p>
<p>链接指示对整个声明都有效：<br>
例如：这条声明语句指出f1是一个不返回任何值的C函数。它有一个类型是函数指针的形参，其中的函数接受一个int形参返回为空。这个链接指示不仅对f1有效，对函数指针同样有效。当我们调用f1时，必须传给它一个C函数的名字或者指向C函数的指针。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// f1是一个C函数，它的形参是一个指向C函数的指针</span><br><span class="line">extern "C" void f1(void(*)(int));</span><br></pre></td></tr></table></figure>
<p>因为链接指示同时作用于声明语句中的所有函数，所以如果希望给C++函数传入一个指向C函数的指针，则必须使用类型别名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FC是一个指向C函数的指针</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">FC</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// f2是一个C++函数，该函数的形参是指向C函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(FC*)</span></span>;</span><br></pre></td></tr></table></figure>
<p>导出C++函数到其他语言：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calc函数可以被C程序调用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">double</span> dparm)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>不过要注意，可被多种语言共享的函数的返回类型或形参类型受到很多限制，比如C根本就不懂类。<br>
有时需要在C和C++中编译同一个源文件，可以利用<code>__cplusplus</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="comment">// 正确：我们正在编译C++程序</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br></pre></td></tr></table></figure>
<p>重载函数与链接指示：<br>
C语言不支持函数重载。因此如果在一组重载函数中有一个是C函数，则其余的必定都是C++函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SmallInt &#123;&#125;;</span><br><span class="line">clas BigNum &#123;&#125;;</span><br><span class="line"><span class="comment">// C函数可以在C或C++程序中调用</span></span><br><span class="line"><span class="comment">// C++函数重载了该函数，可以在C++程序中调用</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> SmallInt <span class="title">calc</span><span class="params">(<span class="keyword">const</span> SmallInt&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> BigNum <span class="title">calc</span><span class="params">(<span class="keyword">const</span> BigNum&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>≖‿≖✧<br>
开心！新年第一天，完成任务一项！ᕙ(⇀‸↼ )ᕗ</p>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">博文</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#高级主题"><span class="toc-number">1.</span> <span class="toc-text"> 高级主题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#标准库特殊设施"><span class="toc-number">1.1.</span> <span class="toc-text"> 标准库特殊设施</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tuple类型"><span class="toc-number">1.1.1.</span> <span class="toc-text"> tuple类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bitset类型"><span class="toc-number">1.1.2.</span> <span class="toc-text"> bitset类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#正则表达式"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#随机数"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 随机数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io库再探"><span class="toc-number">1.1.5.</span> <span class="toc-text"> IO库再探</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用于大型程序的工具"><span class="toc-number">1.2.</span> <span class="toc-text"> 用于大型程序的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#异常处理"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命名空间"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 命名空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多重继承与虚继承"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 多重继承与虚继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特殊工具与技术"><span class="toc-number">1.3.</span> <span class="toc-text"> 特殊工具与技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#控制内存分配"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 控制内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行时类型识别"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 运行时类型识别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#枚举类型"><span class="toc-number">1.3.3.</span> <span class="toc-text"> 枚举类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类成员指针"><span class="toc-number">1.3.4.</span> <span class="toc-text"> 类成员指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#嵌套类"><span class="toc-number">1.3.5.</span> <span class="toc-text"> 嵌套类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#union一种节省空间的类"><span class="toc-number">1.3.6.</span> <span class="toc-text"> union：一种节省空间的类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#局部类"><span class="toc-number">1.3.7.</span> <span class="toc-text"> 局部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#固有的不可移植的特性"><span class="toc-number">1.3.8.</span> <span class="toc-text"> 固有的不可移植的特性</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/&text=C++ Primer, 5th Edition 笔记4"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/&title=C++ Primer, 5th Edition 笔记4"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/&is_video=false&description=C++ Primer, 5th Edition 笔记4"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++ Primer, 5th Edition 笔记4&body=Check out this article: http://conglang.github.io/2015/11/26/note-cpp-primer5-4/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/&title=C++ Primer, 5th Edition 笔记4"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/&title=C++ Primer, 5th Edition 笔记4"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/&title=C++ Primer, 5th Edition 笔记4"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/&title=C++ Primer, 5th Edition 笔记4"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://conglang.github.io/2015/11/26/note-cpp-primer5-4/&name=C++ Primer, 5th Edition 笔记4&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2018 聪
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">博文</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>

<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/fontawesome-all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-74786593-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

    <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?4e074986ce7bd4c6c94338ce1a49c4be";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

<!-- Disqus Comments -->



