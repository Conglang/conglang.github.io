<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="算法之减治法。介绍了使用此方法的算法如插入排序，深度优先(DFS)和广度优先(BFS)查找，，拓扑排序，生成组合对象的生成排列和生成子集、格雷码，减常因子的假币问题、俄式乘法、约瑟夫斯问题，减可变规模的计算中值和选择问题、插值查找、二叉查找树的查找和插入、拈游戏。以及相关题目。">
<meta property="og:type" content="article">
<meta property="og:title" content="Decrease and Conquer">
<meta property="og:url" content="http://conglang.github.io/2015/01/13/decrease-and-conquer/index.html">
<meta property="og:site_name" content="A Stellar Hiker">
<meta property="og:description" content="算法之减治法。介绍了使用此方法的算法如插入排序，深度优先(DFS)和广度优先(BFS)查找，，拓扑排序，生成组合对象的生成排列和生成子集、格雷码，减常因子的假币问题、俄式乘法、约瑟夫斯问题，减可变规模的计算中值和选择问题、插值查找、二叉查找树的查找和插入、拈游戏。以及相关题目。">
<meta property="og:image" content="http://conglang.github.io/img/maze_problem.png">
<meta property="og:image" content="http://conglang.github.io/img/maze_solve.png">
<meta property="og:image" content="http://conglang.github.io/img/pre_courses.png">
<meta property="og:image" content="http://conglang.github.io/img/pre_courses_dfs.png">
<meta property="og:image" content="http://conglang.github.io/img/pre_courses_minus.png">
<meta property="og:image" content="http://conglang.github.io/img/permutation_bottom_up.png">
<meta property="og:image" content="http://conglang.github.io/img/permutation_bottom_up_4.jpg">
<meta property="og:image" content="http://conglang.github.io/img/permutation_johnson_trotter_4.jpg">
<meta property="og:image" content="http://conglang.github.io/img/permutation_lexicographic_4.jpg">
<meta property="og:image" content="http://conglang.github.io/img/combination_bottom_up.jpg">
<meta property="og:image" content="http://conglang.github.io/img/combination_bit.jpg">
<meta property="og:image" content="http://conglang.github.io/img/combination_bottom_up_4.jpg">
<meta property="og:image" content="http://conglang.github.io/img/combination_bit_4.jpg">
<meta property="og:image" content="http://conglang.github.io/img/gray_geometric.png">
<meta property="og:image" content="http://conglang.github.io/img/russian_multiply_example.jpg">
<meta property="og:image" content="http://conglang.github.io/img/jsfs_example.jpg">
<meta property="og:image" content="http://conglang.github.io/img/insert_search_graph.png">
<meta property="og:image" content="http://conglang.github.io/img/insert_search_x_formula.png">
<meta property="og:image" content="http://conglang.github.io/img/pick_game_example.png">
<meta property="og:image" content="http://conglang.github.io/img/pick_game_multiple_bit.png">
<meta property="og:image" content="http://conglang.github.io/img/bad_chocolocate.png">
<meta property="og:updated_time" content="2018-07-31T15:04:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Decrease and Conquer">
<meta name="twitter:description" content="算法之减治法。介绍了使用此方法的算法如插入排序，深度优先(DFS)和广度优先(BFS)查找，，拓扑排序，生成组合对象的生成排列和生成子集、格雷码，减常因子的假币问题、俄式乘法、约瑟夫斯问题，减可变规模的计算中值和选择问题、插值查找、二叉查找树的查找和插入、拈游戏。以及相关题目。">
<meta name="twitter:image" content="http://conglang.github.io/img/maze_problem.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/astro.png">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/astro.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/astro.png">
          
        
    
    <!-- title -->
    <title>Decrease and Conquer</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
  	<link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet">
</head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">博文</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2015/01/16/devide-and-conquer/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2015/01/12/detail/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://conglang.github.io/2015/01/13/decrease-and-conquer/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://conglang.github.io/2015/01/13/decrease-and-conquer/&text=Decrease and Conquer"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://conglang.github.io/2015/01/13/decrease-and-conquer/&title=Decrease and Conquer"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://conglang.github.io/2015/01/13/decrease-and-conquer/&is_video=false&description=Decrease and Conquer"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Decrease and Conquer&body=Check out this article: http://conglang.github.io/2015/01/13/decrease-and-conquer/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://conglang.github.io/2015/01/13/decrease-and-conquer/&title=Decrease and Conquer"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://conglang.github.io/2015/01/13/decrease-and-conquer/&title=Decrease and Conquer"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://conglang.github.io/2015/01/13/decrease-and-conquer/&title=Decrease and Conquer"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://conglang.github.io/2015/01/13/decrease-and-conquer/&title=Decrease and Conquer"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://conglang.github.io/2015/01/13/decrease-and-conquer/&name=Decrease and Conquer&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#减治法"><span class="toc-number">1.</span> <span class="toc-text"> 减治法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#插入排序"><span class="toc-number">1.1.</span> <span class="toc-text"> 插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深度优先查找dfs和广度优先查找bfs"><span class="toc-number">1.2.</span> <span class="toc-text"> 深度优先查找(DFS)和广度优先查找(BFS)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#相关题目"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 相关题目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓扑排序"><span class="toc-number">1.3.</span> <span class="toc-text"> 拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#相关问题"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 相关问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成组合对象的算法"><span class="toc-number">1.4.</span> <span class="toc-text"> 生成组合对象的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#生成排列"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 生成排列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#从底至上生成排列算法"><span class="toc-number">1.4.1.1.</span> <span class="toc-text"> 从底至上生成排列算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#johnson-trotter算法"><span class="toc-number">1.4.1.2.</span> <span class="toc-text"> Johnson-Trotter算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#生成字典序的方法"><span class="toc-number">1.4.1.3.</span> <span class="toc-text"> 生成字典序的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#以n4比较"><span class="toc-number">1.4.1.4.</span> <span class="toc-text"> 以n=4比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生成子集"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 生成子集</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#自底至上方法"><span class="toc-number">1.4.2.1.</span> <span class="toc-text"> 自底至上方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#比特方法"><span class="toc-number">1.4.2.2.</span> <span class="toc-text"> 比特方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#以aa_1a_2a_3a_4比较"><span class="toc-number">1.4.2.3.</span> <span class="toc-text"> 以A=\\{a_1,a_2,a_3,a_4\\}比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#相关题目-2"><span class="toc-number">1.4.2.4.</span> <span class="toc-text"> 相关题目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减常因子算法"><span class="toc-number">1.5.</span> <span class="toc-text"> 减常因子算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#假币问题"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 假币问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#俄式乘法"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 俄式乘法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#约瑟夫斯问题"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 约瑟夫斯问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减可变规模算法"><span class="toc-number">1.6.</span> <span class="toc-text"> 减可变规模算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#计算中值和选择问题"><span class="toc-number">1.6.1.</span> <span class="toc-text"> 计算中值和选择问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插值查找"><span class="toc-number">1.6.2.</span> <span class="toc-text"> 插值查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉查找树的查找和插入"><span class="toc-number">1.6.3.</span> <span class="toc-text"> 二叉查找树的查找和插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#拈游戏"><span class="toc-number">1.6.4.</span> <span class="toc-text"> 拈游戏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#相关题目-3"><span class="toc-number">1.6.5.</span> <span class="toc-text"> 相关题目</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index my4">
        
        
        
          <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Decrease and Conquer
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">A Stellar Hiker</span>
      </span>
      
    <div class="postdate">
        <time datetime="2015-01-13T13:10:36.000Z" itemprop="datePublished">2015-01-13</time>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Algorithm/">Algorithm</a>, <a class="tag-link" href="/tags/C/">C++</a>, <a class="tag-link" href="/tags/Decrease-and-Conquer/">Decrease and Conquer</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="减治法"><a class="markdownIt-Anchor" href="#减治法"></a> 减治法</h2>
<blockquote>
<p><strong>减治法</strong>是一种一般性的算法设计技术，它利用了一个问题给定实例的解和同样问题较小实例的解之间的关系。一旦建立了这样一种关系，我们既可以自顶至下(递归)也可以自底至上地运用它(非递归)。</p>
</blockquote>
<p>减治法有3种主要的变种：</p>
<ul>
<li><strong>减一个常量</strong>，常常是减1(例如插入排序)。</li>
<li><strong>减一个常因子</strong>，常常是减去因子2(例如折半查找)。</li>
<li><strong>减可变规模</strong>(例如欧几里得算法).</li>
</ul>
<h3 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h3>
<blockquote>
<p><strong>插入排序</strong>是减(减1)治法技术在排序问题上的直接应用。无论平均还是最坏，时间复杂度都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>，但在平均情况下效率大约比最差情况快两倍。</p>
</blockquote>
<p>该算法一个较为出众的优势在于，<strong>对于几乎有序的数组，它的性能是很好的，最佳情况是O(n)。</strong><br>
例如，在用快速排序对数组排序的时候，当子数组的规模变得小于某些预定义的值时，我们可以停止该算法的迭代。此时，数组已经基本有序了，可以用插入排序来完成接下来的工作。一般会减少10%的运行时间。</p>
<p>代码示例看<a href="/2014/12/25/sorting/#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">这里</a>。</p>
<h3 id="深度优先查找dfs和广度优先查找bfs"><a class="markdownIt-Anchor" href="#深度优先查找dfs和广度优先查找bfs"></a> 深度优先查找(DFS)和广度优先查找(BFS)</h3>
<blockquote>
<p>**深度优先查找(DFS)和广度优先查找(BFS)**是两种主要的图遍历算法。</p>
</blockquote>
<p>两种算法都有着相同的时间效率：对于邻接矩阵表示法来说是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(|V|^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord"><span class="mord mathrm">∣</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>；对于邻接链表表示法来说是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>V</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(|V|+|E|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mord mathrm">∣</span><span class="mbin">+</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathrm">∣</span><span class="mclose">)</span></span></span></span>。</p>
<ul>
<li>DFS重要的基本应用包括检查图的连通性和无环性。因为DFS在访问了所有和初始顶点有路径相连的顶点之后就会停下来，所以可以检查图的连通性，看看是否所有的顶点都被访问过了。检查无环性则是检查是否有访问过的节点再次被到达。</li>
<li>BFS可以用来求两个给定顶点间边的数量最少的路径。</li>
</ul>
<p>代码示例看<a href="/2015/01/11/graph/#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(Depth-First_Search)">DFS代码</a>和<a href="/2015/01/11/graph/#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(Breadth-First_Search)">BFS代码</a>。两者的比较看<a href="/2015/01/11/graph/#DFS%E4%B8%8EBFS%E6%AF%94%E8%BE%83">这里</a>。</p>
<h4 id="相关题目"><a class="markdownIt-Anchor" href="#相关题目"></a> 相关题目</h4>
<ol>
<li>我们可以用一个代表起点的顶点、一个代表终点的顶点、若干个代表死胡同和通道的顶点来对迷宫建模，迷宫中的通道不止一条，我们必须求出连接起点和终点的迷宫道路。<br>
a. 为下面的迷宫构造一个图。<br>
<img src="/img/maze_problem.png" alt="Image Loading"><br>
解答：<img src="/img/maze_solve.png" alt="Image Loading"><br>
b. 如果你发现自己身处一个迷宫中，你会选用<strong>DFS</strong>遍历还是<s>BFS</s>遍历？</li>
</ol>
<h3 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h3>
<blockquote>
<p>一个<strong>有向图</strong>是一个对边指定了方向的图。<strong>拓扑排序</strong>要求按照这种次序列出它的顶点，使得对于图中的每一条边来说，边的起始顶点总是排在边的结束顶点之前。当且仅当有向图是一个**无环有向图(不包含回路的有向图)**的时候，该问题有解，也就是说，它不包含有向的回路。</p>
</blockquote>
<p>解决拓扑排序问题有<strong>两种算法</strong>。第一种算法基于深度优先查找；第二种算法基于减一技术的直接应用，源删除算法。<br>
<img src="/img/pre_courses.png" alt="代表五门课程先决条件的结构图"></p>
<ul>
<li><strong>DFS算法</strong>：执行一次DFS遍历，并记住顶点变成死端(即退出遍历栈)的顺序。将该次序反过来就得到了拓扑排序的一个解。<br>
<img src="/img/pre_courses_dfs.png" alt="DFS遍历栈，下标数字指出出栈的次序与该问题的解"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> OrderedGraphNode</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	OrderedGraphNode(<span class="built_in">string</span> val) : m_val(val)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">get_val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_val;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_next</span><span class="params">(OrderedGraphNode* m)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!m) <span class="keyword">return</span>;</span><br><span class="line">		m_nexts.push_back(m);</span><br><span class="line">		m-&gt;add_prev(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;OrderedGraphNode*&gt; m_prevs;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;OrderedGraphNode*&gt; m_nexts;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> m_val;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_prev</span><span class="params">(OrderedGraphNode* m)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!m) <span class="keyword">return</span>;</span><br><span class="line">		m_prevs.push_back(m);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(OrderedGraphNode* start, <span class="built_in">unordered_set</span>&lt;OrderedGraphNode*&gt;&amp; visited, <span class="built_in">vector</span>&lt;OrderedGraphNode*&gt;&amp; path)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!start) <span class="keyword">return</span>;</span><br><span class="line">	visited.insert(start);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = start-&gt;m_nexts.begin(); it != start-&gt;m_nexts.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*it &amp;&amp; visited.count(*it) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dfs(*it, visited, path);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	path.push_back(start);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_pre_course</span><span class="params">(<span class="built_in">vector</span>&lt;OrderedGraphNode*&gt; classes, <span class="built_in">vector</span>&lt;OrderedGraphNode*&gt;&amp; result)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (classes.empty()) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// find all nodes without a prev.</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;OrderedGraphNode*&gt; starts;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = classes.begin(); it != classes.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((*it) &amp;&amp; (*it)-&gt;m_prevs.empty()) &#123;starts.push_back(*it);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// for all nodes above, depth first search. Notice they share a visited set.</span></span><br><span class="line">	<span class="built_in">unordered_set</span>&lt;OrderedGraphNode*&gt; visited;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = starts.begin(); it != starts.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		dfs(*it, visited, result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// reverse result.</span></span><br><span class="line">	reverse(result.begin(), result.end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">OrderedGraphNode <span class="title">c1</span><span class="params">(<span class="string">"c1"</span>)</span></span>;</span><br><span class="line">	<span class="function">OrderedGraphNode <span class="title">c2</span><span class="params">(<span class="string">"c2"</span>)</span></span>;</span><br><span class="line">	<span class="function">OrderedGraphNode <span class="title">c3</span><span class="params">(<span class="string">"c3"</span>)</span></span>;</span><br><span class="line">	<span class="function">OrderedGraphNode <span class="title">c4</span><span class="params">(<span class="string">"c4"</span>)</span></span>;</span><br><span class="line">	<span class="function">OrderedGraphNode <span class="title">c5</span><span class="params">(<span class="string">"c5"</span>)</span></span>;</span><br><span class="line">	c1.add_next(&amp;c3);</span><br><span class="line">	c2.add_next(&amp;c3);</span><br><span class="line">	c3.add_next(&amp;c4);</span><br><span class="line">	c3.add_next(&amp;c5);</span><br><span class="line">	c4.add_next(&amp;c5);</span><br><span class="line">	OrderedGraphNode* temp[<span class="number">5</span>] = &#123;&amp;c1, &amp;c2, &amp;c3, &amp;c4, &amp;c5&#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;OrderedGraphNode*&gt; classes(temp, temp+<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;OrderedGraphNode*&gt; result;</span><br><span class="line">	find_pre_course(classes, result);</span><br><span class="line">	for_each(result.begin(), result.end(), [](OrderedGraphNode* node)&#123; <span class="built_in">cout</span> &lt;&lt; node-&gt;get_val() &lt;&lt; <span class="string">" "</span>;&#125;);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"Pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>源删除算法</strong>：不断地做这样一件事，在余下的有向图中求出一个源，它是一个没有输入边的顶点，然后把它和所有从它出发的边都删除。(如果有多个这样的源，任选一个。如果没有这样的源，停止，无解)顶点被删除的顺序就是拓扑排序问题的一个解。<br>
<img src="/img/pre_courses_minus.png" alt="拓扑排序问题的源删除算法的图示。在每次迭代的时候，没有输入边的节点从有向图中删除"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="keyword">class</span> OrderedGraphNode</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	OrderedGraphNode(<span class="built_in">string</span> val) : m_val(val)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delete_me</span><span class="params">()</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = m_nexts.begin(); it != m_nexts.end(); ++it)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (*it) &#123;(*it)-&gt;delete_prev(<span class="keyword">this</span>);&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		m_nexts.clear();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">get_val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> m_val;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_next</span><span class="params">(OrderedGraphNode* m)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!m) <span class="keyword">return</span>;</span><br><span class="line">		m_nexts.push_back(m);</span><br><span class="line">		m-&gt;add_prev(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;OrderedGraphNode*&gt; m_prevs;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;OrderedGraphNode*&gt; m_nexts;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">string</span> m_val;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_prev</span><span class="params">(OrderedGraphNode* m)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!m) <span class="keyword">return</span>;</span><br><span class="line">		m_prevs.push_back(m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">delete_prev</span><span class="params">(OrderedGraphNode* m)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!m) <span class="keyword">return</span>;</span><br><span class="line">		m_prevs.erase(remove(m_prevs.begin(), m_prevs.end(), m), m_prevs.end());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_pre_course</span><span class="params">(<span class="built_in">vector</span>&lt;OrderedGraphNode*&gt; classes, <span class="built_in">vector</span>&lt;OrderedGraphNode*&gt;&amp; result)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (classes.empty()) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// find node without prev.</span></span><br><span class="line">	<span class="keyword">while</span> (!classes.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> it = classes.begin(); it != classes.end(); ++it)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ((*it) &amp;&amp; (*it)-&gt;m_prevs.empty())</span><br><span class="line">			&#123;</span><br><span class="line">				result.push_back(*it);</span><br><span class="line">				(*it)-&gt;delete_me();</span><br><span class="line">				classes.erase(remove(classes.begin(), classes.end(), *it), classes.end());</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function">OrderedGraphNode <span class="title">c1</span><span class="params">(<span class="string">"c1"</span>)</span></span>;</span><br><span class="line">	<span class="function">OrderedGraphNode <span class="title">c2</span><span class="params">(<span class="string">"c2"</span>)</span></span>;</span><br><span class="line">	<span class="function">OrderedGraphNode <span class="title">c3</span><span class="params">(<span class="string">"c3"</span>)</span></span>;</span><br><span class="line">	<span class="function">OrderedGraphNode <span class="title">c4</span><span class="params">(<span class="string">"c4"</span>)</span></span>;</span><br><span class="line">	<span class="function">OrderedGraphNode <span class="title">c5</span><span class="params">(<span class="string">"c5"</span>)</span></span>;</span><br><span class="line">	c1.add_next(&amp;c3);</span><br><span class="line">	c2.add_next(&amp;c3);</span><br><span class="line">	c3.add_next(&amp;c4);</span><br><span class="line">	c3.add_next(&amp;c5);</span><br><span class="line">	c4.add_next(&amp;c5);</span><br><span class="line">	OrderedGraphNode* temp[<span class="number">5</span>] = &#123;&amp;c1, &amp;c2, &amp;c3, &amp;c4, &amp;c5&#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;OrderedGraphNode*&gt; classes(temp, temp+<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;OrderedGraphNode*&gt; result;</span><br><span class="line">	find_pre_course(classes, result);</span><br><span class="line">	for_each(result.begin(), result.end(), [](OrderedGraphNode* node)&#123; <span class="built_in">cout</span> &lt;&lt; node-&gt;get_val() &lt;&lt; <span class="string">" "</span>;&#125;);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"Pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="相关问题"><a class="markdownIt-Anchor" href="#相关问题"></a> 相关问题</h4>
<ol>
<li><strong>名人问题</strong>。n人人群中的名人是这样定义的：他一个人都不认识，但其他人都认识他。我们的任务是要找出人群中的名人，但只能向人们问这种问题：“你认识他/她吗？”设计一个高效的算法来确定人群中的名人，或者判定人群中没有名人。最坏情况下，该算法要问多少个问题？<br>
<strong>思路</strong>：通过询问一个问题，每次减少一个人选。递归进行。对最后一人再询问一或两个问题确认。<br>
第一步：从人群中选择两个人A和B。问A是否认识B。如果A认识B，删除A。如果A不认识B，删除B。<br>
第二步：对剩下n-1个人递归进行上一步。<br>
第三步：<br>
如果第二步结束后没有人，那就没有名人。<br>
如果剩下一人非A非B，是C，问C是否认识A中被删除的人。如果C说不认识，问第一步里被删除的人是否认识C。如果被删之人说认识，那么C是名人。其余情况皆是没有名人。<br>
如果剩下一人是B，问B是否认识A，如果B不认识，B是名人，否则没有名人。<br>
如果剩下一人是A，问B是否认识A，如果B认识，A是名人，否则没有名人。</li>
</ol>
<h3 id="生成组合对象的算法"><a class="markdownIt-Anchor" href="#生成组合对象的算法"></a> 生成组合对象的算法</h3>
<blockquote>
<p>在设计生成基本组合对象的算法时，减一技术是一种非常自然的选择。这类算法中最高效的类型是最小变化算法。然而，组合对象的数量增长得如此之快，使得实际应用中，即使最高效的算法也只能用来解决这类问题的一些非常小的实例。</p>
</blockquote>
<h4 id="生成排列"><a class="markdownIt-Anchor" href="#生成排列"></a> 生成排列</h4>
<blockquote>
<p>问题：生成{1,…,n}的所有n!个排列。有两种解法，从底至上生成排列算法、Johnson-Trotter算法。</p>
</blockquote>
<h5 id="从底至上生成排列算法"><a class="markdownIt-Anchor" href="#从底至上生成排列算法"></a> 从底至上生成排列算法</h5>
<p>假设(n-1)!个排列的问题已经解决，可以把n插入到n-1个元素的每一种排列中的n个可能位置中去，得到较大规模问题的一个解。<br>
<img src="/img/permutation_bottom_up.png" alt="从底至上生成排列"><br>
可以一开始从右到左把n插入到12…(n-1)的位置中，然后每处理一个{1,…,n-1}的新排列时，再调换方向。<br>
以这种次序生成排列的好处是，满足<strong>最小变化</strong>要求：仅仅需要交换直接前趋中的两个元素就能得到任何一个新的序列。有利于提高算法速度，对使用这些排列的应用也有好处。</p>
<h5 id="johnson-trotter算法"><a class="markdownIt-Anchor" href="#johnson-trotter算法"></a> Johnson-Trotter算法</h5>
<p><strong>移动元素</strong>的概念。给一个排列中的每个元素k赋予一个方向。用元素上画一个小箭头来表示。如果元素k的箭头指向一个相邻的较小元素，那么它在这个排列中是移动的。<br>
例如，排列\overrightarrow3\overleftarrow2\overrightarrow4\overleftarrow1中，3和4是移动的，2和1不是。</p>
<p><strong>算法思路</strong>：将第一个排列初始化为\overleftarrow1\overleftarrow2...\overleftarrow n。如果仍然存在移动元素k，那么循环：找到最大的移动元素k，把k和它箭头指向的相邻元素互换，调转所有大于k的元素的方向，将新排列添加到列表。</p>
<p>如，对n=3应用该算法：</p>
\overleftarrow1\overleftarrow2\overleftarrow3 \mbox{,  } \overleftarrow1\overleftarrow3\overleftarrow2 \mbox{,  } \overleftarrow3\overleftarrow1\overleftarrow2 \mbox{,  } \overrightarrow3\overleftarrow2\overleftarrow1 \mbox{,  } \overleftarrow2\overrightarrow3\overleftarrow1 \mbox{,  } \overleftarrow2\overleftarrow1\overrightarrow3

<p>这个算法是生成排列的最有效的算法之一。该算法实现的运行时间和排列的数量是呈正比的，也就是说属于集合<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>!</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span>。好慢的，只怪要求生成的项实在太多了。</p>
<p>这个算法生成的排列的次序不是非常自然。如果是<strong>字典序</strong>的话，上述结果应该是：</p>
123\mbox{ }132\mbox{ }213\mbox{ }231\mbox{ }312\mbox{ }321

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// structure of directioned num</span></span><br><span class="line"><span class="keyword">struct</span> DirNum</span><br><span class="line">&#123;</span><br><span class="line">	DirNum(<span class="keyword">int</span> m) : m_num(m), m_is_left(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">	<span class="keyword">int</span> m_num;</span><br><span class="line">	<span class="keyword">bool</span> m_is_left;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_biggest_move_element</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;DirNum&gt;&amp; elements)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">result</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">val</span><span class="params">(INT_MIN)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((elements[i].m_is_left &amp;&amp; i != <span class="number">0</span> &amp;&amp; elements[i].m_num &gt; elements[i<span class="number">-1</span>].m_num) || </span><br><span class="line">			(!elements[i].m_is_left &amp;&amp; i != elements.size()<span class="number">-1</span> &amp;&amp; elements[i].m_num &gt; elements[i+<span class="number">1</span>].m_num))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (elements[i].m_num &gt; val)</span><br><span class="line">			&#123;</span><br><span class="line">				val = elements[i].m_num;</span><br><span class="line">				result = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redirect_bigger_than_this</span><span class="params">(<span class="built_in">vector</span>&lt;DirNum&gt;&amp; elements, <span class="keyword">int</span> val)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = elements.begin(); it != elements.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((*it).m_num &gt; val)</span><br><span class="line">		&#123;</span><br><span class="line">			(*it).m_is_left = !(*it).m_is_left;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">johnson_trotter</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;DirNum&gt; &gt;&amp; result)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// initialize first sequence to 123...n(all left)</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;DirNum&gt; temp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">DirNum <span class="title">t</span><span class="params">(i)</span></span>;</span><br><span class="line">		temp.push_back(t);</span><br><span class="line">	&#125;</span><br><span class="line">	result.push_back(temp);	<span class="comment">// add first sequence to result</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">big_index</span><span class="params">(<span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> ((big_index = find_biggest_move_element(temp)) &gt; <span class="number">-1</span>)	<span class="comment">// find biggest move element</span></span><br><span class="line">	&#123;</span><br><span class="line">		DirNum* me = &amp;temp[big_index];</span><br><span class="line">		DirNum* next = me-&gt;m_is_left ? &amp;temp[big_index<span class="number">-1</span>] : &amp;temp[big_index+<span class="number">1</span>];</span><br><span class="line">		swap(*me, *next);	<span class="comment">// swap it with its pointed neighbour</span></span><br><span class="line">		redirect_bigger_than_this(temp, next-&gt;m_num);	<span class="comment">// rearrange all bigger element's direction</span></span><br><span class="line">		result.push_back(temp);	<span class="comment">// add new sequence to result</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;DirNum&gt; &gt; result;</span><br><span class="line">	johnson_trotter(<span class="number">3</span>, result);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = result.begin(); it != result.end(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		for_each((*it).begin(), (*it).end(), [](DirNum m)&#123;<span class="built_in">cout</span> &lt;&lt; m.m_num &lt;&lt; <span class="string">"("</span> &lt;&lt; (m.m_is_left ? <span class="string">"←"</span> : <span class="string">"→"</span>) &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="string">" "</span>;&#125;);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">"Pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="生成字典序的方法"><a class="markdownIt-Anchor" href="#生成字典序的方法"></a> 生成字典序的方法</h5>
<p>请看这几道leetcode题目。<br>
[Brute Force] | <a href="https://github.com/Conglang/MyLeetCode/blob/master/src/Permutations.cpp" target="_blank" rel="external">Permutations</a><br>
[Brute Force] | <a href="https://github.com/Conglang/MyLeetCode/blob/master/src/Permutations_II.cpp" target="_blank" rel="external">Permutations II</a><br>
[Arrays] | <a href="https://github.com/Conglang/MyLeetCode/blob/master/src/Next_Permutation.cpp" target="_blank" rel="external">Next Permutation</a></p>
<h5 id="以n4比较"><a class="markdownIt-Anchor" href="#以n4比较"></a> 以n=4比较</h5>
<p><img src="/img/permutation_bottom_up_4.jpg" alt="自底向上的最小变化算法"><br>
<img src="/img/permutation_johnson_trotter_4.jpg" alt="Johnson-Trotter算法"><br>
<img src="/img/permutation_lexicographic_4.jpg" alt="字典序算法"></p>
<h4 id="生成子集"><a class="markdownIt-Anchor" href="#生成子集"></a> 生成子集</h4>
<blockquote>
<p>问题：生成一个抽象集合A=\\{a_1,···,a_2\\}的所有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.664392em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>个子集。有两种解法：自底至上方法，比特方法。</p>
</blockquote>
<p>相关题目[Brute Force] | <a href="https://github.com/Conglang/MyLeetCode/blob/master/src/Combinations.cpp" target="_blank" rel="external">Combinations</a></p>
<h5 id="自底至上方法"><a class="markdownIt-Anchor" href="#自底至上方法"></a> 自底至上方法</h5>
<p>集合A={a1,···,an}的所有子集可以分为两组：不包含an的子集和包含an的子集。前一组就是{a1,…a{n-1}}的所有子集，而后一组中的每个元素都可以通过把an添加到\\{a1,···,a_{n-1}\\}的每一个子集中来获得。</p>
<p><img src="/img/combination_bottom_up.jpg" alt="从底至上生成子集"></p>
<h5 id="比特方法"><a class="markdownIt-Anchor" href="#比特方法"></a> 比特方法</h5>
<p>n个元素集合A=\\{a_1,...,a_n\\}的所有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.664392em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>个子集和长度为n的所有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.664392em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>个比特串之间有一一对应关系。建立这样一种对应关系的最简单方法是为每一个子集制定一个比特串，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>属于该子集，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">b_i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">b</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span></span>；如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>不属于该子集，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b_i=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">b</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">0</span></span></span></span>。<br>
例如，对于n=3的情况：<br>
<img src="/img/combination_bit.jpg" alt="n=3时比特串与子集的对应关系"></p>
<p>生成的排列次序仍然是很不自然的。<br>
如果是<strong>挤压序</strong>，所有包含aj的子集必须紧排在所有包含{a1,…,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>}的子集后面。<br>
如果是<strong>二进制反射格雷码</strong>，每一个比特串和它的直接前趋之间仅仅相差一个比特位。</p>
<h5 id="以aa_1a_2a_3a_4比较"><a class="markdownIt-Anchor" href="#以aa_1a_2a_3a_4比较"></a> 以A=\\{a_1,a_2,a_3,a_4\\}比较</h5>
<p><img src="/img/combination_bottom_up_4.jpg" alt="自底至上方法"><br>
<img src="/img/combination_bit_4.jpg" alt="比特方法"></p>
<h5 id="相关题目-2"><a class="markdownIt-Anchor" href="#相关题目-2"></a> 相关题目</h5>
<ol>
<li>写一个<strong>生成所有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.664392em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>个长度为n的比特串的递归算法</strong>。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bit_string_recursive</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; output, <span class="built_in">string</span>&amp; cur)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// generate recursively all the bit strings of a given length</span></span><br><span class="line">	<span class="comment">// input: a positive integer n</span></span><br><span class="line">	<span class="comment">// output: all bit strings of length n as contents of output</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		output.push_back(cur);</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cur.push_back(<span class="string">'0'</span>);</span><br><span class="line">		bit_string_recursive(n<span class="number">-1</span>, output, cur);</span><br><span class="line">		cur.pop_back();</span><br><span class="line">		cur.push_back(<span class="string">'1'</span>);</span><br><span class="line">		bit_string_recursive(n<span class="number">-1</span>, output, cur);</span><br><span class="line">		cur.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; output;</span><br><span class="line">	<span class="built_in">string</span> cur;</span><br><span class="line">	bit_string_recursive(<span class="number">3</span>, output, cur);</span><br><span class="line">	copy(output.begin(), output.end(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"Pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>写一个<strong>生成所有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.664392em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>个长度为n的比特串的非递归算法</strong>，它用数组来实现比特串并且不使用二进制加法。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bit_string_nonrecursive</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; output)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// generate nonrecursively all the bit strings of a given length</span></span><br><span class="line">	<span class="comment">// input: a positive integer n</span></span><br><span class="line">	<span class="comment">// output: all bit strings of length n</span></span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">cur</span><span class="params">(n,<span class="string">'0'</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">k</span><span class="params">(n<span class="number">-1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (k &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		output.push_back(cur);</span><br><span class="line">		k = n - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; cur.at(k) == <span class="string">'1'</span>) &#123;--k;&#125;</span><br><span class="line">		<span class="keyword">if</span> (k &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cur[k] = <span class="string">'1'</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = k+<span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				cur[i] = <span class="string">'0'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; output;</span><br><span class="line">	bit_string_nonrecursive(<span class="number">3</span>, output);</span><br><span class="line">	copy(output.begin(), output.end(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"Pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>设计一个通用的减一算法来生成次数为n的<strong>格雷码</strong>。<br>
格雷码有一种<strong>几何表达方式</strong>，就是把它的bit值映射到一个n维的立方体上。<br>
如图为bit值为1,2,3的情况。<br>
<img src="/img/gray_geometric.png" alt="bit值为1,2,3时格雷码对n维立方体的几何映射"><br>
从000开始，按图中箭头遍历。即000 001 011 010 110 111 101 100。<br>
<strong>思路</strong>：得到n-1的输出队列后复制两份。第一份在所有比特序列前加0，第二份在所有比特序列前加1。将第二份反向，添加到第一份的后面，就是n的输出队列。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gray_code</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; output)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		output.push_back(<span class="string">"0"</span>);</span><br><span class="line">		output.push_back(<span class="string">"1"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		gray_code(n<span class="number">-1</span>, output);</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; copy1(output);</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; copy2(output);</span><br><span class="line">		for_each(copy1.begin(), copy1.end(), [](<span class="built_in">string</span>&amp; n)&#123;n = <span class="string">"0"</span> + n;&#125;);</span><br><span class="line">		for_each(copy2.begin(), copy2.end(), [](<span class="built_in">string</span>&amp; n)&#123;n = <span class="string">"1"</span> + n;&#125;);</span><br><span class="line">		copy(copy2.rbegin(), copy2.rend(), back_inserter(copy1));</span><br><span class="line">		output = copy1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; output;</span><br><span class="line">	gray_code(<span class="number">3</span>, output);</span><br><span class="line">	copy(output.begin(), output.end(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"Pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另一道关于<a href="https://github.com/Conglang/MyLeetCode/blob/master/src/Gray_Code.cpp" target="_blank" rel="external">生成格雷码的题目</a>。写法上比前面的好。</p>
</blockquote>
<ol start="4">
<li>设计一个减治算法来<strong>生成n个元素的k个分量的所有组合</strong>，也就是说，一个给定的n元素集合的所有k元素子集。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">choose_k_of_n</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; input, <span class="keyword">int</span> i, <span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; output, <span class="built_in">string</span>&amp; cur)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// generate all k-subsets of &#123;i, i+1, ..., n&#125; stored in array input</span></span><br><span class="line">	<span class="comment">// in descending order of their components</span></span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		output.push_back(cur);</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// j &lt; input.size() - k + 1是为了给剩下的几位留出足够的元素。</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; input.size() - k + <span class="number">1</span>; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			cur[k<span class="number">-1</span>] = input[j];</span><br><span class="line">			choose_k_of_n(input, j+<span class="number">1</span>, k<span class="number">-1</span>, output, cur);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> temp[<span class="number">5</span>] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>&#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; input(temp, temp+<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; output;</span><br><span class="line">	<span class="built_in">string</span> cur;</span><br><span class="line">	cur.resize(<span class="number">4</span>);</span><br><span class="line">	choose_k_of_n(input, <span class="number">0</span>, <span class="number">4</span>, output, cur);</span><br><span class="line">	copy(output.begin(), output.end(), ostream_iterator&lt;<span class="built_in">string</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"Pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>格雷码与汉诺塔的相通之处。</li>
</ol>
<h3 id="减常因子算法"><a class="markdownIt-Anchor" href="#减常因子算法"></a> 减常因子算法</h3>
<p>减常因子算法的例子有：用天平来辨别假币、俄式乘法、约瑟夫斯问题、折半查找、用平方求幂。</p>
<h4 id="假币问题"><a class="markdownIt-Anchor" href="#假币问题"></a> 假币问题</h4>
<blockquote>
<p>在n枚外观相同的硬币中，有一枚是假币。在一架天平上，我们可以比较任意两组硬币，得知哪一组比另一组更重，但不知道重多少。假币比真币轻。要求设计算法检测这枚假币。<br>
折半查找不是最高效的解法。</p>
</blockquote>
<p>把硬币分成三堆，每堆n/3个硬币更好。<br>
代码实现假币问题的三分算法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// assume fake coin is lighter and there is only one fake coin.</span><br><span class="line">int calculate_weight_of_group(const vector&lt;int&gt;&amp; coins, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">	int weight(0);</span><br><span class="line">	for (int i = start; i &lt; end; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		weight += coins[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return weight;</span><br><span class="line">&#125;</span><br><span class="line">//---------------------------------------------------</span><br><span class="line">void find_fake_coin_by_divided_by_3(const vector&lt;int&gt;&amp; coins, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">	if (start == end-1)	// the coin is fake</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; "fake coin is number " &lt;&lt; start &lt;&lt; " weight " &lt;&lt; coins[start];</span><br><span class="line">	&#125;else</span><br><span class="line">	&#123;</span><br><span class="line">		// divide the coins into three piles of n/3, n/3, n-2(n/3) coins</span><br><span class="line">		int div1 = start + (end - start) / 3;</span><br><span class="line">		int div2 = div1 + (end - start) / 3;</span><br><span class="line">		// weigh the first two piles</span><br><span class="line">		int weight1(calculate_weight_of_group(coins, start, div1));</span><br><span class="line">		int weight2(calculate_weight_of_group(coins, div1, div2));</span><br><span class="line">		if (weight1 == weight2)	// if they weigh the same</span><br><span class="line">		&#123;</span><br><span class="line">			// discard all of them and continue with the coins of the third pile</span><br><span class="line">			find_fake_coin_by_divided_by_3(coins, div2, end);</span><br><span class="line">		&#125;else if (weight1 &lt; weight2)	// else continue with the lighter of the first two piles</span><br><span class="line">		&#123;</span><br><span class="line">			find_fake_coin_by_divided_by_3(coins, start, div1);</span><br><span class="line">		&#125;else</span><br><span class="line">		&#123;</span><br><span class="line">			find_fake_coin_by_divided_by_3(coins, div1, div2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//---------------------------------------------------</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; coins(10, 5);</span><br><span class="line">	coins[7] = 3;</span><br><span class="line">	find_fake_coin_by_divided_by_3(coins, 0, coins.size());</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	system("Pause");</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="俄式乘法"><a class="markdownIt-Anchor" href="#俄式乘法"></a> 俄式乘法</h4>
<blockquote>
<p>假设n和m是两个正整数，计算它们的乘积。用n的值作为实例规模的量度。<br>
如果n是偶数：</p>
</blockquote>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi><mo>=</mo><mfrac><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></mfrac><mo>×</mo><mn>2</mn><mi>m</mi></mrow><annotation encoding="application/x-tex">n\times m = \frac{n}{2} \times 2m
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.10756em;"></span><span class="strut bottom" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit">n</span><span class="mbin">×</span><span class="mord mathit">m</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit">n</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">×</span><span class="mord mathrm">2</span><span class="mord mathit">m</span></span></span></span></span></p>
<p>如果n是奇数：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac><mo>×</mo><mn>2</mn><mi>m</mi><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n\times m = \frac{n-1}{2} \times 2m + m
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.32144em;"></span><span class="strut bottom" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit">n</span><span class="mbin">×</span><span class="mord mathit">m</span><span class="mrel">=</span><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">2</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">×</span><span class="mord mathrm">2</span><span class="mord mathit">m</span><span class="mbin">+</span><span class="mord mathit">m</span></span></span></span></span></p>
<p>通过应用这个公式，并以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mi>m</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1\times m=m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mbin">×</span><span class="mord mathit">m</span><span class="mrel">=</span><span class="mord mathit">m</span></span></span></span>作为算法停止的条件，可以用递归或迭代计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n\times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mbin">×</span><span class="mord mathit">m</span></span></span></span>的乘积。</p>
<p>例如，用该算法计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mn>0</mn><mo>×</mo><mn>6</mn><mn>5</mn></mrow><annotation encoding="application/x-tex">50\times 65</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span><span class="mord mathrm">0</span><span class="mbin">×</span><span class="mord mathrm">6</span><span class="mord mathrm">5</span></span></span></span>。<br>
<img src="/img/russian_multiply_example.jpg" alt="用俄式乘法计算"></p>
<p>这个算法使得硬件实现的速度非常快，因为使用移位就可以完成二进制数的折半和加倍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">russe_nonrecursive</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// implements multiplication à la russe nonrecursively</span></span><br><span class="line">	<span class="comment">// input: two positive integers n and m</span></span><br><span class="line">	<span class="comment">// output: the product of n and m</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (n != <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) plus += m;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> plus+m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">russe_recursive</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// implements multiplication à la russe recursively</span></span><br><span class="line">	<span class="comment">// input: two positive integers n and m</span></span><br><span class="line">	<span class="comment">// output: the product of n and m</span></span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;<span class="keyword">return</span> russe_recursive(n/<span class="number">2</span>, <span class="number">2</span>*m);&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;<span class="keyword">return</span> m;&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="keyword">return</span> russe_recursive((n<span class="number">-1</span>)/<span class="number">2</span>, <span class="number">2</span>*m) + m;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 * 25 = "</span> &lt;&lt; russe_nonrecursive(<span class="number">5</span>, <span class="number">25</span>) &lt;&lt; <span class="string">" solved nonrecursively."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 * 25 = "</span> &lt;&lt; russe_recursive(<span class="number">5</span>, <span class="number">25</span>) &lt;&lt; <span class="string">" solved recursively."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"52 * 78 = "</span> &lt;&lt; russe_nonrecursive(<span class="number">52</span>, <span class="number">78</span>) &lt;&lt; <span class="string">" solved nonrecursively."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"52 * 78 = "</span> &lt;&lt; russe_recursive(<span class="number">52</span>, <span class="number">78</span>) &lt;&lt; <span class="string">" solved recursively."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"Pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="约瑟夫斯问题"><a class="markdownIt-Anchor" href="#约瑟夫斯问题"></a> 约瑟夫斯问题</h4>
<blockquote>
<p>让n个人围成一个圈，并将他们从1到n编上号码。从编号为1的那个人那里开始这个残酷的计数，每次消去第二个人直到只留下一个幸存者。问题就是要求算出幸存者的号码J(n)。</p>
</blockquote>
<p>可怕的故事！约瑟夫斯是一个著名的犹太历史学家，参与并记录了公元66~70年犹太人反抗罗马的起义。约瑟夫斯作为一个将军，设法守住了裘达伯特的堡垒达47天之久，但在城市陷落了以后，他和40名顽强的将士在附近的一个洞穴中避难。在那里，这些叛乱者表决说“要投降毋宁死”。于是，约瑟夫斯建议每个人应该轮流杀死他旁边的人，而这个顺序是由抽签决定的。约瑟夫斯有预谋地抓到了最后一签，并且，作为洞穴中的两个幸存人之一，他说服了他原来的牺牲品一起投降罗马。<br>
<img src="/img/jsfs_example.jpg" alt="约瑟夫斯问题的实例(a)n=6(b)n=7。下标数字指出了在第几轮操作的时候该位置上的人被消去了。问题的解分别是J(6)=5, J(7)=7"></p>
<p><strong>思路</strong>：把奇数n和偶数n情况分开考虑。</p>
<ol>
<li>如果n为偶数，即n=2k。对整个圆圈处理第一遍之后，生成了同样问题的规模减半的实例。(比如一共4人，初始位置为3的人第2轮会在2号位置上，3=2*2-1。括号里的是本轮的总人数。)唯一差别是位置的编号。同一个人的新旧位置关系是：(旧=2新-1)</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mo>(</mo><mn>2</mn><mi>k</mi><mo>)</mo><mo>=</mo><mn>2</mn><mi>J</mi><mo>(</mo><mi>k</mi><mo>)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">J(2k)=2J(k)-1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span></span></p>
<ol start="2">
<li>如果n为奇数，即n=2k+1。第一轮消去了所有偶数位置上的人。把紧接着消去的位置1上的人也加进来，留下一个规模为k的实例。(比如一共3人，初始位置为3的人第2轮会在1号位置上，3=2*1+1。括号里的是本轮的总人数。)同一个人的新旧位置关系是：(旧=2新+1)</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mo>(</mo><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>=</mo><mn>2</mn><mi>J</mi><mo>(</mo><mi>k</mi><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">J(2k+1)=2J(k)+1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">+</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span></span></p>
<p>**一个神奇的解法！**对n本身做一次向左的循环移位得到J(n)。如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mo>(</mo><mn>6</mn><mo>)</mo><mo>=</mo><mi>J</mi><mo>(</mo><msub><mrow><mn>1</mn><mn>1</mn><mn>0</mn></mrow><mn>2</mn></msub><mo>)</mo><mo>=</mo><msub><mrow><mn>1</mn><mn>0</mn><mn>1</mn></mrow><mn>2</mn></msub><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">J(6)=J({110}_2)={101}_2=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathrm">6</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">=</span><span class="mord"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">5</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mo>(</mo><mn>7</mn><mo>)</mo><mo>=</mo><mi>J</mi><mo>(</mo><msub><mrow><mn>1</mn><mn>1</mn><mn>1</mn></mrow><mn>2</mn></msub><mo>)</mo><mo>=</mo><msub><mrow><mn>1</mn><mn>1</mn><mn>1</mn></mrow><mn>2</mn></msub><mo>=</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">J(7)=J({111}_2)={111}_2=7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathrm">7</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">=</span><span class="mord"><span class="mord textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">1</span><span class="mord mathrm">1</span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">7</span></span></span></span>。</p>
<h3 id="减可变规模算法"><a class="markdownIt-Anchor" href="#减可变规模算法"></a> 减可变规模算法</h3>
<p><strong>减可变规模算法</strong>的一次迭代和另一次迭代时消减的规模是变化的。例子如：欧几里得算法、选择问题的基于分区的算法、插值查找和二叉查找树中的查找及插入操作。</p>
<h4 id="计算中值和选择问题"><a class="markdownIt-Anchor" href="#计算中值和选择问题"></a> 计算中值和选择问题</h4>
<blockquote>
<p><strong>选择问题</strong>是求一个n个数列表的第k个最小元素的问题。这个数字被称为第k个顺序统计量。<br>
这个问题的一个更有意思的情况是在k=n/2时，它要求找出这样一个元素，该元素比列表中的一半元素大，又比另一半元素小。这个中间的值被称为<strong>中值</strong>。</p>
</blockquote>
<p><strong>中值问题的思路</strong>：先假设s是分区的分割位置。如果s=k，中轴p就是选择问题的解。如果s&gt;k，p是s的左边区域中第k小的元素。如果s&lt;k，p是s的右边区域中第k-s小的元素。从而减小问题规模。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//---------------------------------------------------</span><br><span class="line">int find_kth_smallest_element(vector&lt;int&gt;&amp; array, int start, int end, int k)</span><br><span class="line">&#123;</span><br><span class="line">	int pivot = array[start];</span><br><span class="line">	int left(start+1),right(end);</span><br><span class="line">	while (left &lt;= right)</span><br><span class="line">	&#123;</span><br><span class="line">		while (array[left] &lt;= pivot &amp;&amp; left &lt;= right) &#123;++left;&#125;</span><br><span class="line">		while (array[right] &gt;= pivot &amp;&amp; left &lt;= right) &#123;--right;&#125;</span><br><span class="line">		if (left &lt;= right)</span><br><span class="line">		&#123;</span><br><span class="line">			swap(array[left], array[right]);</span><br><span class="line">			++left; --right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	left = min(left, end);</span><br><span class="line">	right = max(right, start);</span><br><span class="line">	swap(array[start], array[right]);</span><br><span class="line">	int partition = right;</span><br><span class="line">	if (partition &gt; k) &#123; return find_kth_smallest_element(array, start, partition-1, k);&#125;</span><br><span class="line">	else if (partition &lt; k) &#123;return find_kth_smallest_element(array, partition+1, end, k-partition);&#125;</span><br><span class="line">	else &#123;return array[partition];&#125;</span><br><span class="line">&#125;</span><br><span class="line">//---------------------------------------------------</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int temp[5] = &#123;40,30,50,10,20&#125;;</span><br><span class="line">	vector&lt;int&gt; array(temp, temp+5);</span><br><span class="line">	cout &lt;&lt; "3rd least element in array is : " &lt;&lt; find_kth_smallest_element(array, 0, 4, 3-1) &lt;&lt; endl;</span><br><span class="line">	system("Pause");</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插值查找"><a class="markdownIt-Anchor" href="#插值查找"></a> 插值查找</h4>
<blockquote>
<p>插值查找为了找到用来和查找键进行比较的数组元素，考虑了查找键的值。某种意义上模仿了在电话号码簿上查找名字的方式。如果叫Brown，我们不会翻到号码簿的中间，而是翻到很靠近开头的地方。</p>
</blockquote>
<p><img src="/img/insert_search_graph.png" alt="如何在插值查找中确定下标值"><br>
<img src="/img/insert_search_x_formula.png" alt="x的计算方程，即穿越点(l,A[l])和点(r,A[r])直线的标准方程(相似三角形)"><br>
如图：A在l<sub>r范围内有序，由预查值v带入线性方程求得x。求x实际对应值A(x)。如果A[x]&lt;v，在x+1</sub>r之间找。反之，在l~x-1之间找。</p>
<p>对于较小的文件，折半查找可能更好，但对于更大的文件和那些比较的开销非常大或者访问的成本非常高的应用，插值查找更值得考虑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">interpolation_search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; datas, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> val)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> inter = start + ((val - datas[start]) * (end - start) / (datas[end] - datas[start]));</span><br><span class="line">	<span class="keyword">if</span> (inter &lt; start || inter &gt; end) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (datas[inter] &lt; val)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> interpolation_search(datas, inter+<span class="number">1</span>, end, val);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (datas[inter] &gt; val)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> interpolation_search(datas, start, inter<span class="number">-1</span>, val);</span><br><span class="line">	&#125;<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> inter;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; datas(temp, temp+<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"find number "</span> &lt;&lt; <span class="number">7</span> &lt;&lt; <span class="string">" in vector, index: "</span> &lt;&lt; interpolation_search(datas, <span class="number">0</span>, <span class="number">9</span>, <span class="number">7</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> temp1[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>&#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; datas1(temp1, temp1+<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"find number "</span> &lt;&lt; <span class="number">11</span> &lt;&lt; <span class="string">" in vector, index: "</span> &lt;&lt; interpolation_search(datas1, <span class="number">0</span>, <span class="number">9</span>, <span class="number">11</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"Pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二叉查找树的查找和插入"><a class="markdownIt-Anchor" href="#二叉查找树的查找和插入"></a> 二叉查找树的查找和插入</h4>
<p>迭代的过程中，树的高度的减少通常不相同，所以是减可变规模算法。<br>
二叉查找树的<a href="/2015/01/10/tree/#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91(Binary_Search_Tree)">讲解和例子见这里</a>。</p>
<h4 id="拈游戏"><a class="markdownIt-Anchor" href="#拈游戏"></a> 拈游戏</h4>
<blockquote>
<p>其中一个例子是：有一堆n个棋子。两个玩家轮流从堆中拿走最少1个、最多m个棋子。每次拿走的棋子数都可以不同，但能够拿走的上下限数量是不变的。如果每个玩家都做出了最佳选择，哪个玩家能够胜利拿到最后那个棋子？是先走的还是后走的？</p>
</blockquote>
<p><img src="/img/pick_game_example.png" alt="单堆拈游戏，每次能够拿走的最大棋子数m=4。图中的数字表示堆中的棋子数n。败局用圆圈表示：在胜局下出的致胜步用粗箭头表示"><br>
结论：当且仅当n不是m+1的倍数的时候，n个棋子的实例是一个胜局。胜利的策略是在每次拿走n mod (m+1)个棋子。如果背离这个策略，则会把胜局留给对手。</p>
<blockquote>
<p>扩展为多堆的情况。它的解很奇怪，基于堆中棋子数的二进制表示。b1, b2, …, bn分别是各堆棋子数的二进制表示。求它们的<strong>二进制数位和</strong>，即对每一位分别求和并忽略进位。可以证实，当且仅当二进制数位和中包含至少一个1时，该实例是一个胜局；相反地，当且仅当二进制数位和只包含0的时候，实例是一个败局。</p>
</blockquote>
<p><img src="/img/pick_game_multiple_bit.png" alt="对于最常玩的游戏实例来说，它的二进制数位是"><br>
因为该和包含一个1，该实例对于先走的玩家来说，是一个胜局。要找到该胜局的一个胜手，玩家需要改变三个比特串中的一个，使得新的二进制数位和仅包含0.不难看出，为了做到这一点，我们只有从第一堆中拿走两个棋子。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">// 代码写得不算好，寻机修改。</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//============================================================</span><br><span class="line">class Robot</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void pick(vector&lt;int&gt;&amp; piles, int allowed_pick);</span><br><span class="line">	void single_pick(vector&lt;int&gt;&amp; piles, int allowed_pick);</span><br><span class="line">	void multi_pick(vector&lt;int&gt;&amp; piles, int allowed_pick);</span><br><span class="line">&#125;;</span><br><span class="line">//---------------------------------------------------</span><br><span class="line">void Robot::pick( vector&lt;int&gt;&amp; piles, int allowed_pick )</span><br><span class="line">&#123;</span><br><span class="line">	int no_zero_pile_num(0);</span><br><span class="line">	for (auto p = piles.begin(); p != piles.end(); ++p)</span><br><span class="line">	&#123;</span><br><span class="line">		if (*p)&#123;++no_zero_pile_num;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (no_zero_pile_num &gt; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		multi_pick(piles, allowed_pick);</span><br><span class="line">	&#125;else</span><br><span class="line">	&#123;</span><br><span class="line">		single_pick(piles, allowed_pick);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//---------------------------------------------------</span><br><span class="line">void Robot::single_pick( vector&lt;int&gt;&amp; piles, int allowed_pick )</span><br><span class="line">&#123;</span><br><span class="line">	for (int i = 0; i &lt; piles.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		if(!piles[i]) &#123;continue;&#125;</span><br><span class="line">		int minus(piles[i] % (allowed_pick+1));	// 每次拿走n mod (m+1)个</span><br><span class="line">		string helpmsg = minus ? "CalulateSingleRobot(堆,石子):	" : "RandomSingleRobot(堆,石子):	";</span><br><span class="line">		minus = max(1, minus);</span><br><span class="line">		piles[i] -= minus;</span><br><span class="line">		cout &lt;&lt; helpmsg &lt;&lt; i+1 &lt;&lt; " " &lt;&lt; minus &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//---------------------------------------------------</span><br><span class="line">void Robot::multi_pick( vector&lt;int&gt;&amp; piles, int allowed_pick )</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int sum(0);</span><br><span class="line">	for (auto p = piles.begin(); p != piles.end(); ++p)</span><br><span class="line">	&#123;</span><br><span class="line">		sum ^= *p;	// 计算多堆的二进制数位和是否为0</span><br><span class="line">	&#125;</span><br><span class="line">	if (sum != 0)	// 不为0时是胜局，进行计算</span><br><span class="line">	&#123;</span><br><span class="line">		int index(0);	// index是从右向左数，第几位不为0</span><br><span class="line">		while (!(sum&amp;(1 &lt;&lt; index)))</span><br><span class="line">		&#123;</span><br><span class="line">			++index;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i = 0; i &lt; piles.size(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			if (piles[i] &amp; (1&lt;&lt;index))	// 当前堆在这个位置上恰好是1，去了这个1。</span><br><span class="line">			&#123;</span><br><span class="line">				int old(piles[i]);</span><br><span class="line">				piles[i] ^= 1&lt;&lt;index;</span><br><span class="line">				cout &lt;&lt; "CalculateMultiRobot(堆,石子):	" &lt;&lt; i+1 &lt;&lt; " " &lt;&lt; old-piles[i] &lt;&lt; endl;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else	// 为0时是败局，随机选数</span><br><span class="line">	&#123;</span><br><span class="line">		int pile = rand()%piles.size();</span><br><span class="line">		int num = rand()%allowed_pick;</span><br><span class="line">		piles[pile-1] -= min(piles[pile-1], num);</span><br><span class="line">		cout &lt;&lt; "RandomMultiRobot(堆,石子):	" &lt;&lt; pile &lt;&lt; " " &lt;&lt; min(piles[pile-1], num) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//============================================================</span><br><span class="line">class Player</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	void pick(vector&lt;int&gt;&amp; piles, int allowed_pick);</span><br><span class="line">&#125;;</span><br><span class="line">//---------------------------------------------------</span><br><span class="line">void Player::pick( vector&lt;int&gt;&amp; piles, int allowed_pick )</span><br><span class="line">&#123;</span><br><span class="line">	int pile(0),num(0);</span><br><span class="line">	auto check = [&amp;]()-&gt;bool&#123;</span><br><span class="line">		if (pile &gt; piles.size()|| pile == 0 || num &gt; allowed_pick || num &gt; piles[pile-1])</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; "重新输入" &lt;&lt; endl;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;;</span><br><span class="line">	cout &lt;&lt; "TheTestPlayer(堆,石子):	";</span><br><span class="line">	cin &gt;&gt; pile &gt;&gt; num;</span><br><span class="line">	if (!check())</span><br><span class="line">	&#123;</span><br><span class="line">		pick(piles, allowed_pick);</span><br><span class="line">	&#125;else</span><br><span class="line">	&#123;</span><br><span class="line">		piles[pile-1] -= num;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//============================================================</span><br><span class="line">class Game</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Game() : m_player_first(false),m_allowed_pick(5),m_player_win(true) &#123;&#125;</span><br><span class="line">	void start();</span><br><span class="line">	void set_piles(vector&lt;int&gt;&amp; piles, int&amp; m_allowed_pick);</span><br><span class="line">	void print_all_piles(const vector&lt;int&gt;&amp; piles);</span><br><span class="line">	void main_loop();</span><br><span class="line">	bool pile_valid();</span><br><span class="line">	void finish();</span><br><span class="line">private:</span><br><span class="line">	Robot robot;</span><br><span class="line">	Player player;</span><br><span class="line">	vector&lt;int&gt; piles;</span><br><span class="line">	bool m_player_first;</span><br><span class="line">	bool m_player_win;</span><br><span class="line">	int m_allowed_pick;</span><br><span class="line">&#125;;</span><br><span class="line">//---------------------------------------------------</span><br><span class="line">void Game::set_piles( vector&lt;int&gt;&amp; piles, int&amp; m_allowed_pick )</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; "欢迎进行拈游戏，请输入每堆石子情况，空格隔开，-1结束。" &lt;&lt; endl;</span><br><span class="line">	piles.clear();</span><br><span class="line">	int num(0);</span><br><span class="line">	while(cin &gt;&gt; num &amp;&amp; num != -1)</span><br><span class="line">	&#123;</span><br><span class="line">		piles.push_back(num);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; "输入每次最多拿几个石子。" &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; m_allowed_pick;</span><br><span class="line">&#125;</span><br><span class="line">//---------------------------------------------------</span><br><span class="line">void Game::print_all_piles( const vector&lt;int&gt;&amp; piles )</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; "---";</span><br><span class="line">	copy(piles.begin(), piles.end(), ostream_iterator&lt;int&gt;(cout, "---"));</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//---------------------------------------------------</span><br><span class="line">void Game::start()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; "==========================================" &lt;&lt; endl;</span><br><span class="line">	set_piles(piles, m_allowed_pick);</span><br><span class="line">	cout &lt;&lt; "开始玩拈游戏，你先手？输入Y或N。" &lt;&lt; endl;</span><br><span class="line">	string temp("N");</span><br><span class="line">	cin &gt;&gt; temp;</span><br><span class="line">	if (temp == "Y" || temp == "y")</span><br><span class="line">	&#123;</span><br><span class="line">		m_player_first = true;</span><br><span class="line">	&#125;else</span><br><span class="line">	&#123;</span><br><span class="line">		m_player_first = false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//---------------------------------------------------</span><br><span class="line">void Game::main_loop()</span><br><span class="line">&#123;</span><br><span class="line">	while (true)</span><br><span class="line">	&#123;</span><br><span class="line">		if (m_player_first)</span><br><span class="line">		&#123;</span><br><span class="line">			player.pick(piles, m_allowed_pick);</span><br><span class="line">			print_all_piles(piles);</span><br><span class="line">			if (!pile_valid()) &#123;m_player_win = true; break;&#125;</span><br><span class="line">			robot.pick(piles, m_allowed_pick);</span><br><span class="line">			print_all_piles(piles);</span><br><span class="line">			if (!pile_valid()) &#123;m_player_win = false; break;&#125;</span><br><span class="line">		&#125;else</span><br><span class="line">		&#123;</span><br><span class="line">			robot.pick(piles, m_allowed_pick);</span><br><span class="line">			print_all_piles(piles);</span><br><span class="line">			if (!pile_valid()) &#123;m_player_win = false; break;&#125;</span><br><span class="line">			player.pick(piles, m_allowed_pick);</span><br><span class="line">			print_all_piles(piles);</span><br><span class="line">			if (!pile_valid()) &#123;m_player_win = true; break;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//---------------------------------------------------</span><br><span class="line">bool Game::pile_valid()</span><br><span class="line">&#123;</span><br><span class="line">	int pile_count(0);</span><br><span class="line">	for_each(piles.begin(), piles.end(), [&amp;](int p)&#123;if (p) pile_count+=p;&#125;);</span><br><span class="line">	if (pile_count == 0) &#123;return false;&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">//---------------------------------------------------</span><br><span class="line">void Game::finish()</span><br><span class="line">&#123;</span><br><span class="line">	if (m_player_win)&#123;cout &lt;&lt; "玩家胜利！" &lt;&lt; endl;&#125;</span><br><span class="line">	else&#123;cout &lt;&lt; "机器胜利！" &lt;&lt; endl;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//============================================================</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Game game;</span><br><span class="line">	while(true)</span><br><span class="line">	&#123;</span><br><span class="line">		game.start();</span><br><span class="line">		game.main_loop();</span><br><span class="line">		game.finish();</span><br><span class="line">	&#125;</span><br><span class="line">	system("Pause");</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="相关题目-3"><a class="markdownIt-Anchor" href="#相关题目-3"></a> 相关题目</h4>
<ol>
<li>
<p><strong>另类单堆拈游戏</strong>规定谁拿走最后一个棋子就输了。该游戏的其他条件都不变，即该堆棋子有n个，每次每个玩家最多拿走m个，最少拿走1个。请指出游戏的胜局和败局是是怎样的？<br>
<strong>答案</strong>：败局是n mod (m+1) = 1，胜利的策略是每次拿走(n-1) mod (m+1)的棋子。</p>
</li>
<li>
<p><strong>坏巧克力</strong>。两个玩家轮流掰一块<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m\times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mbin">×</span><span class="mord mathit">n</span></span></span></span>格的巧克力，其中一块<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mbin">×</span><span class="mord mathrm">1</span></span></span></span>的小块是坏的。每次掰只能顺着方格的边界，沿直线一掰到底。每掰一次，掰的人把两块中不含坏巧克力的那块吃掉，谁碰到最后那块坏巧克力就算输了。这个游戏中，先走还是后走好？<br>
<strong>答案</strong>:相当于多堆拈游戏，每边到达坏巧克力块的距离就是一堆，然后二进制数位和计算。<br>
<img src="/img/bad_chocolocate.png" alt="坏巧克力问题可以看作四堆"></p>
</li>
<li>
<p><strong>翻薄饼</strong>。有n张大小互不相同的薄饼，一张叠在另一张上面。允许大家把一个翻板插到一个薄饼下面，然后可以把板上面的这叠薄饼翻个身。我们的目标是根据薄饼的大小重新安排它们的位置，最大的饼要放在最下面。<br>
<strong>答案</strong>：找到最大的，翻到顶，然后全部翻过来。重复。</p>
</li>
</ol>
<p>[1] 算法设计与分析基础(第2版)</p>

  </div>
</article>



        
    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">博文</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#减治法"><span class="toc-number">1.</span> <span class="toc-text"> 减治法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#插入排序"><span class="toc-number">1.1.</span> <span class="toc-text"> 插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深度优先查找dfs和广度优先查找bfs"><span class="toc-number">1.2.</span> <span class="toc-text"> 深度优先查找(DFS)和广度优先查找(BFS)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#相关题目"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 相关题目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓扑排序"><span class="toc-number">1.3.</span> <span class="toc-text"> 拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#相关问题"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 相关问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成组合对象的算法"><span class="toc-number">1.4.</span> <span class="toc-text"> 生成组合对象的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#生成排列"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 生成排列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#从底至上生成排列算法"><span class="toc-number">1.4.1.1.</span> <span class="toc-text"> 从底至上生成排列算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#johnson-trotter算法"><span class="toc-number">1.4.1.2.</span> <span class="toc-text"> Johnson-Trotter算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#生成字典序的方法"><span class="toc-number">1.4.1.3.</span> <span class="toc-text"> 生成字典序的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#以n4比较"><span class="toc-number">1.4.1.4.</span> <span class="toc-text"> 以n=4比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生成子集"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 生成子集</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#自底至上方法"><span class="toc-number">1.4.2.1.</span> <span class="toc-text"> 自底至上方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#比特方法"><span class="toc-number">1.4.2.2.</span> <span class="toc-text"> 比特方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#以aa_1a_2a_3a_4比较"><span class="toc-number">1.4.2.3.</span> <span class="toc-text"> 以A=\\{a_1,a_2,a_3,a_4\\}比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#相关题目-2"><span class="toc-number">1.4.2.4.</span> <span class="toc-text"> 相关题目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减常因子算法"><span class="toc-number">1.5.</span> <span class="toc-text"> 减常因子算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#假币问题"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 假币问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#俄式乘法"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 俄式乘法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#约瑟夫斯问题"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 约瑟夫斯问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减可变规模算法"><span class="toc-number">1.6.</span> <span class="toc-text"> 减可变规模算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#计算中值和选择问题"><span class="toc-number">1.6.1.</span> <span class="toc-text"> 计算中值和选择问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#插值查找"><span class="toc-number">1.6.2.</span> <span class="toc-text"> 插值查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉查找树的查找和插入"><span class="toc-number">1.6.3.</span> <span class="toc-text"> 二叉查找树的查找和插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#拈游戏"><span class="toc-number">1.6.4.</span> <span class="toc-text"> 拈游戏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#相关题目-3"><span class="toc-number">1.6.5.</span> <span class="toc-text"> 相关题目</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://conglang.github.io/2015/01/13/decrease-and-conquer/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://conglang.github.io/2015/01/13/decrease-and-conquer/&text=Decrease and Conquer"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://conglang.github.io/2015/01/13/decrease-and-conquer/&title=Decrease and Conquer"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://conglang.github.io/2015/01/13/decrease-and-conquer/&is_video=false&description=Decrease and Conquer"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Decrease and Conquer&body=Check out this article: http://conglang.github.io/2015/01/13/decrease-and-conquer/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://conglang.github.io/2015/01/13/decrease-and-conquer/&title=Decrease and Conquer"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://conglang.github.io/2015/01/13/decrease-and-conquer/&title=Decrease and Conquer"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://conglang.github.io/2015/01/13/decrease-and-conquer/&title=Decrease and Conquer"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://conglang.github.io/2015/01/13/decrease-and-conquer/&title=Decrease and Conquer"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://conglang.github.io/2015/01/13/decrease-and-conquer/&name=Decrease and Conquer&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 聪
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">博文</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>

</html>

<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/fontawesome-all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-74786593-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

    <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?4e074986ce7bd4c6c94338ce1a49c4be";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

<!-- Disqus Comments -->



